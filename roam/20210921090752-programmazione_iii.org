:PROPERTIES:
:ID:       6e332ccc-6881-4fff-a9e9-fd1f14286559
:ROAM_ALIASES: ProgIII
:END:
#+title: Programmazione III
[[id:f956b52b-6fe3-4040-94e5-7474d1813a38][$university]]
* Info Corso
- Orari:
  + Mar: 9-11
  + Gio: 11-13
  + Mer: 9-11 (Lab1)
- Testi:
  + [[id:21f4f4a4-aaa4-4932-9f39-65ed93de3116][Java: How to Program, Late Objects]]
- IDE
  + IntelliJ IDEA
* Teoria
** Programmazione ad Oggetti
*** Concetti Base
Secondo _Alan Kay (Smalltalk)_
- Oggetti
  /fornitori di servizi/
  + Stato
    - attributi
  + Tipo/Classe
- Richieste/Metodi - /delega al metodo, si conosce l'API non l'implementazione/
  + modificano lo stato
  + invio richieste ad altri oggetti
  + comunicazione di informazioni
- Object-oriented Design
  + progettazione orientato ad O

- Classe/Istanza
  + astratto/concreto
    - concreto anche in memoria nello Heap
*** p. procedurale vs p. oggetti
- Procedurale
  + Algoritmi + Strutture Dati
- Oggetti
  + Oggetti + Collaborazione
    /si scorporano funzionalitá diverse in oggetti diversi:/ *delega*
    a) dati + algoritmi
    b) interfacce
*** Gerarchia
- kind-of hierarchy
- part-of hierarchy
**** ereditarieta'
**** polimorfismo
***** Binding Dinamico
:PROPERTIES:
:ID:       c893d363-1f4f-4de6-bbe9-7e5157caec8d
:END:
_Binding statico_, all'atto della compilazione
_Binding dinamico_, l'esecutore puó controllare i tipi degli oggetti, e decidere a runtime il body del metodo da eseguire
- esegue l'implementazione piú specifica possibile
- solo sui metodi, le variabili non vanno a fare overriding

Estremamente modulare e scalabile, meccanismo di delaga
***** Classi Astratte
Utilizzate come interfaccia comune e pubblica, la sottoclasse andrá a implementare i dettagli
***** Interfacce
Non possono avere metodi non astratti
- non sono soggette all'ereditarietá singola, una classe puó implementare tutte le interfacce di cui ha bisogro
***** Overloading
Definizione di firma alternativa di metodo esistente
A tempo _statico_ viene scelta la firma, é bloccante e se ci sono eventuali overloading vengono persi
- a runtime si discende solamente la catena di ereditarietá
***** Overriding
Diverso dall'Overloading in quanto le firme sono le stesse
**** reflection
*** Tipi Generici
Introdotti per scrivere codice generico, applicabile a piú tipi di dati
- *type checking statico*
- il compilatore previa compatibilitá tra tipo attuale e generico, sostituisce il tipo attuale a E
  + /erasure/
- vincoli/restrizioni sul tipo T: upperbound al tipo parametrico
  + =extends Comparable <T>.=
  + =extends= a una singola classe
    * ma multiple inferfacce
**** Raw types
Utilizzando Object direttamente, in questo modo peró il compilatore non puó controllare la correttezza dei tipi
**** Collezioni
Vincoli sintattici per evitare errori a Runtime che non sarebbero rilevati:
- quindi le =Collection= sono controllate per Nome del tipo, non viene considerata l'ereditarietá
  + si risolve utilizzando l'upcasting
Per risolvere e definire una =Collection= di qualsiasi cosa
- =Collection<?>.=
- si utilizza la /wildcard/
  + per restringerlo si utilizza anche in questo caso =extends=
*** Interfacce
- Collection
  + Add()
- Iterator
  + hasNext()
  + next()
*** Classi e Interfacce innestate
Innestando una classe dentro l'altra si facilita il codice mantenendo i contenenti privati
- questo vale sia dalla classe interna che quella estesna
Per information hiding la classe interna puó essere solo meno visibile o uguale a quella esternaPer information hiding la classe interna puó essere solo meno visibile o uguale a quella esternanon puó sempre rispondere
- le classe =IN= hanno un puntatore =outerThis= che permette di fare riferemento al contenitore
  + tramite quello hanno accesso come fossero locali

**** Classi innestate in interfacce
- Interfaccia publica
  + classe statica che rappresenta l'implementazione di default dell'Iterfaccia
- si puó estendere oppure

Possibile avere classi nested anonime definendo in line
- =return new Iteratore(){ ... }=
Posso essere ancora piú sintetico utilizzando le =lambda expression=
- ovviamente non deve esserci ambiguitá per quanto riguarda i parametri, un'interfaccia con metodi non ambigui e con poche righe di codice si presta ad una =lambda=
- inoltre é possibile omette i tipi dei parametri se sono inferibili
- é possibile omettere graffe e =return= se si tratta di una singola istruzione, deve essere una funzione (restituire un valore)
- se il paremetro é uno si possono omettere le parentesi tonde
*** Pattern Architetturali
Una classe =Kernel= che utilizza una =Interfaccia Modulo= cui poi si sceglierá una implementazione con una =Implementazione del Modulo=
*** IO
- Flussi di byte
  + InputStream
  + OutputStream
  + PrintStream
- File
  + FileReader
  + FileWriter
Utile comporre stream
#+begin_code java
Buffered Reader in = new BufferedReader(new FileReader("es.txt"))
#+end_code
Per scrivere e leggere dati primitivi:
- DataInputStream
- DataOutputStream
Per scrivere e leggere oggetti (=Serializable=)
- ObjectInputStream
- ObjectOutputStream
- file testuali
  + Scanner
  + File
  + PrintWriter
- file binari
  + FileInputStream
  + FileOutputStream
Da File

*** GUI
- =AWT= - Abstact Window Toolkit
- =SWING=
  + =JFrame=
  + =JApplet=
  + =JDialog=

** Programmazione ad Eventi
*** Event-Driven Programming
Differentemente da un classico programma, che ad un input restituisce un output seguendo un suo flusso di controllo e solo raramente si attende input dal utente, questa metodologia consiste in procedure che rispondono a certi eventi
- /event handlers/
- /events/

Si distinguono due fasi:
- Ciclo di individuazione degli eventi
- Gestione degli eventi

Dopo essere stati creati gli /event-handlers/ devono essere associati come /listener/ ad un evento di una specifica sorgente, componente la =GUI=

**** Eventi
In =Java=
Oggetti derivati dalla classe =EventObject=
- eventi /semantici/
  + su componenti virtuali dell'interfaccia
- eventi /low-level/
  + eventi fisici relativi al mouse o tastiera

Sono gestiti con un meccanismo di _delega_
- la sorgente, generato un evento, passa un *oggetto* che descrive l'evento ad un listener
  + registrato presso la sorgente
  + il passaggio dell'evento cousa l'invocazione di un metodo del /listener/
**** Sorgenti
I diversi componenti dell'interfaccia
- =JButton=
- =JTextField=
- =Component=
- =Window=
**** Listener
O /event-handler/, istanza di una classe che contiene metodi per gestire gli eventi
Per ogni tipo di evento é definita una interfaccia che il /listener/ deve implementare
- =ActionListener=
  + =void addActionListener(ActionListener I)=
- =MouseListener=
- =MouseMotionListener=
- =WindowListener=

Per non dover implementare tutti i metodi dell'interfaccia che ci interessa sono state introdotte le /classi filtro/
- implementazioni di default delle interfacce dei listener
  + metodi che non fanno nulla
  + si fa /overriding/ solamente dei metodi di gestione che ci servono

- =WindowListener= -> =WindowAdapter=






*** Organizzazione e uso GUI
*** Model View Controller
=MVC=
- Model
  + memorizza e recupera i dati
  + mantiene lo stato dell'applicazione
- View
  + gestisce l'interfaccia
  + visualizza i dati del /Model/
  + gestisce l'interazione con l'utente
- Controller
  + interpreta l'input dell'utente
  + istruisce il /Model/ in base all'input

Separa le implementazioni, in questo modo sono indipendenti e facilmente sostituibili

** Programmazione Multithread
/Stesso processo - Esecuzione concorrente di istruzioni/
** Programmazione in Rete
*** Architettura Client-Server
*** Socket
*** Polimorfismo
*** Esecuzione Distribuita
* Laboratorio
