:PROPERTIES:
:ID:       3e9b697a-f7a8-4c9b-995d-da2d51202299
:ROAM_ALIASES: LPP
:END:
#+title: Linguaggi e Paradigmi di Programmazione
[[id:f956b52b-6fe3-4040-94e5-7474d1813a38][$university]]
Prof: Luca Padovani
* Info Corso
- Orario
  + Lun 16-18
  + Gio 9-11
  + Ven 16-18
- Testi
  + [[id:f46e95c3-14c2-4dda-b150-f8ca209495d1][Introduction to the Theory of Programming Languages]]
  + [[id:8f3dfc67-9e04-4cc6-8958-98559505065c][Haskell: the Craft of Functional Programming]]
  + [[id:dfb13901-7195-44df-843e-5601b65ad3b4][Programming in Haskell]]
  + Modern Java in Action
- Links
  +  https://boystrange.github.io/LPP/
- Esame
  + Esercizi di programmazione Haskell in tempo limitato
  + Teoria
    - Fondamenti del paradigma funzionale
  + Esercizi (Java 8) e Domande - 9 CFU


* Teoria
** Introduzione
Il paradigma funzionale mette le funzioni allo stesso livello delle variabili
- e' possibile definire funzioni che trasformano funzioni, che restituiscono funzioni, che utilizzano funzioni in input
*** Paradigmi e Storia
- imperativo
  + C, Pascal
  + programma come sequenza di comandi da eseguire
    - l'esecuzione modifica lo stato della macchina ad ogni istruzione
- object-oriented
  + Smalltalk
  + oggetti che comunicano tra loro
    - permette di gestire piu' facilmente la complessita'
  + programma come interazioni (metodi) tra oggetti
    - le interazioni modificano lo stato della macchina
    - i metodi sono riconducibili al paradigma imperativo
- funzionale
  + Haskell
  + espressione valutazionale restituisce un risultato

Negli anni:
- '50
  + Assembly
  + FORTRAN
    - formula translator
    - procedure, espressioni
  + COBOL
    - per gestione aziendale, introduce il record
- '60
  + ALGOL
    - forma BNF
    - indipendente dall'architettura
    - blocchi, variabili locali, ricorsione
  + BASIC
    - facile da imparare ma poco strutturato
  + Simula 67
    - classi, oggetti, ereditarieta'
- '70
  + Pascal
    - programmazione strutturata, tipi per evitare errori
    - ideale per imparare a programmare
  + Smalltalk
    - programmazione ad oggetti estrema, tutto e' un oggetto
    - l'unica operazione possibile e' l'invio di messaggi, metodi
  + C
- '80
  + Ada
    - evoluzione di Pascal con concorrenza e tipi astratti
    - sviluppado dal ministero della difesa USA
  + C++
  + PostScript
    - scripting basato sullo stack, interpretato dalle stampanti
  + Perl
    - linguaggio interpretato
- '90
  + Python
  + Java
  + PHP
  + JavaScript
** Haskel
*** Storia
- $\lambda$ calcolo
  + Alonzo Church
    - calcolare con le funzioni, cosi' come con in numeri
    - tutto e' una funzione con 1 IN e 1 OUT
      + funzioni anonime
        - identita'
          + $\lambda x,x$
  + Haskell Curry
    - currying
- LISP - anni '50
  + John McCarthy
    - elaborazione informazione non-numerica/simbolica
    - LISP = List Processor
      + cons e map nascono qui
    - primo _garbage collector_
- ML
- SASL, KRC, Miranda
  + linguaggi _lazy_ con valutazione solo al momento della richiesta della funzione
  + SASL introduce guardie e currying
- Haskell - anni '90
  + linguaggio lazy, standardizzato
  + separazione tra puro e impuro
    - monadi
  + overloading
  + grosso impatto sul calcolo parallelo
*** Casi di Studio
**** Contatore accessi Web
- [[https://boystrange.github.io/LPP/HitCounter][Source]]
Relazione biunivoca tra IP e utenti unici in accesso

Java
#+begin_src java
public static int counter(InputStream stream) {
    Scanner scanner = new Scanner(stream);
    Set<String> clients = new HashSet<>();
    while (scanner.hasNextLine()) {
        String line = scanner.nextLine();
        String ip = line.substring(0, line.indexOf(' ') + 1);
        clients.add(ip);
    }
    return clients.size();
}
#+end_src
Bash
#+begin_src bash
cut -d' ' -f1 | sort -u | wc -l
#+end_src
Haskell
#+begin_src haskell
import Data.List (nub);
counter :: String -> Int
counter = length . nub . map (\line -> takeWhile (/= ' ') line) . lines
#+end_src
Java 8
#+begin_src java
public static long counter(InputStream stream) {
    InputStreamReader reader = new InputStreamReader(stream);
    return new BufferedReader(reader)
        .lines()
        .map(line -> line.substring(0, line.indexOf(' ') + 1))
        .distinct()
        .count();
}
#+end_src
