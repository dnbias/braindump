:PROPERTIES:
:ID:       3e9b697a-f7a8-4c9b-995d-da2d51202299
:ROAM_ALIASES: LPP
:END:
#+title: Linguaggi e Paradigmi di Programmazione
[[id:f956b52b-6fe3-4040-94e5-7474d1813a38][$university]]
Prof: Luca Padovani
* Info Corso
- Orario
  + Lun 16-18
  + Gio 9-11
  + Ven 16-18
- Testi
  + [[id:f46e95c3-14c2-4dda-b150-f8ca209495d1][Introduction to the Theory of Programming Languages]]
  + [[id:8f3dfc67-9e04-4cc6-8958-98559505065c][Haskell: the Craft of Functional Programming]]
  + [[id:dfb13901-7195-44df-843e-5601b65ad3b4][Programming in Haskell]]
  + Modern Java in Action
- Links
  +  https://boystrange.github.io/LPP/
- Esame
  + Esercizi di programmazione Haskell in tempo limitato
  + Teoria
    - Fondamenti del paradigma funzionale
  + Esercizi (Java 8) e Domande - 9 CFU


* Teoria
** Introduzione
Il paradigma funzionale mette le funzioni allo stesso livello delle variabili
- é possibile definire funzioni che trasformano funzioni, che restituiscono funzioni, che utilizzano funzioni in input
*** Paradigmi e Storia
- imperativo
  + C, Pascal
  + programma come sequenza di comandi da eseguire
    - l'esecuzione modifica lo stato della macchina ad ogni istruzione
- object-oriented
  + Smalltalk
  + oggetti che comunicano tra loro
    - permette di gestire piu' facilmente la complessita'
  + programma come interazioni (metodi) tra oggetti
    - le interazioni modificano lo stato della macchina
    - i metodi sono riconducibili al paradigma imperativo
- funzionale
  + Haskell
  + espressione valutazionale restituisce un risultato

Negli anni:
- '50
  + Assembly
  + FORTRAN
    - formula translator
    - procedure, espressioni
  + COBOL
    - per gestione aziendale, introduce il record
- '60
  + ALGOL
    - forma BNF
    - indipendente dall'architettura
    - blocchi, variabili locali, ricorsione
  + BASIC
    - facile da imparare ma poco strutturato
  + Simula 67
    - classi, oggetti, ereditarieta'
- '70
  + Pascal
    - programmazione strutturata, tipi per evitare errori
    - ideale per imparare a programmare
  + Smalltalk
    - programmazione ad oggetti estrema, tutto e' un oggetto
    - l'unica operazione possibile e' l'invio di messaggi, metodi
  + C
- '80
  + Ada
    - evoluzione di Pascal con concorrenza e tipi astratti
    - sviluppado dal ministero della difesa USA
  + C++
  + PostScript
    - scripting basato sullo stack, interpretato dalle stampanti
  + Perl
    - linguaggio interpretato
- '90
  + Python
  + Java
  + PHP
  + JavaScript
** \lambda-calcolo
Ci si restringe sull'essenza della programmazione in linguaggio funzionale
- si distilla un piccolo linguaggio facilmente studiabile

Differenze tra /linguaggio/ e /calcolo/
- il calcolo é confluente
  + il risultato non dipende dalle azioni intraprese per raggiungerlo
- non é deterministico

*** Concetti
- processo di valutazione / =riduzione=
- funzioni con singolo argomento / =currificate= (Haskell Curry)
  + funzioni di ordine superiore
    * accettano come argomenti funzioni / restituiscono altre funzioni
  + agendo per specializzazioni
- linguaggi
  + =eager=
  + =lazy=
- Sistema di =Tipi= / Algoritmo di =Inferenza=
*** Funzioni
**** Punto di vista estensionale
$f = \{(0,1),(1,2),(2,5),\cdots\}$
**** Punto di vista intensionale
$f(x) = x^{2} + 1$
*** Sintassi
- Variabili
  + $Var = \{x,y,z.\cdots\}$
    * infinito
- Sintassi
  + $M,N ::= x \mid (\lambda x.M) \mid (M N)$
- Terminologia
  + $(\lambda x.M)$ astrazione o funzione con argomento $x$ e corpo $M$
  + $(M N)$ applicazione della funzione $M$ all'argomento $N$
- Esempi
  + $(\lambda x.x)$ - Funzione Identitá
  + $((\lambda x.(xx))(\lambda y.(yy)))$ - loop infinito
  + $(\lambda f.(\lambda x.(f(f x))))$

**** Convenzioni Sintattiche
- parentesi esterne omesse
- corpo delle astrazioni si estende a destra
  - a destra del punto
- l'applicazione é associativa a sinistra
**** Variabili Libere e Legate
- $x$ in $M$ é legata se compare in sotto-termine
- diciamo che un'occorrenza di $x$ in $M$ é libera altrimenti
Esempi
- $\lambda x.\: x$
  + nessuna variabile libera => termine chiuso
- $x \: y \: z$
  + tutte le variabili sono libere
- $(\lambda x.\: x \: y) \: x$
  + $x$ sia legata che libera
***** Sostituzione
- $M\{N/y\}$ é ottenuta sostituendo le occorrenze libere di $y$ in $M$ con $N$
- evitare la cattura delle variabili libere di $N$ per non alterarne il senso
  + le variabili libere sono definite esternamente allo scope della astrazione, non posso modificarle
*** Relazioni di Equivalenza
**** \alpha-conversione
$y \notin fv(M) \implies \lambda x.M \iff_{\alpha} \lambda y.M\{y/x\}$
* Laboratorio
** Haskel
*** Storia
- $\lambda$ calcolo
  + Alonzo Church
    - calcolare con le funzioni, cosi' come con in numeri
    - tutto e' una funzione con 1 IN e 1 OUT
      + funzioni anonime
        - identita'
          + $\lambda x,x$
  + Haskell Curry
    - currying
- LISP - anni '50
  + John McCarthy
    - elaborazione informazione non-numerica/simbolica
    - LISP = List Processor
      + cons e map nascono qui
    - primo _garbage collector_
- ML
- SASL, KRC, Miranda
  + linguaggi _lazy_ con valutazione solo al momento della richiesta della funzione
  + SASL introduce guardie e currying
- Haskell - anni '90
  + linguaggio lazy, standardizzato
  + separazione tra puro e impuro
    - monadi
  + overloading
  + grosso impatto sul calcolo parallelo
*** Casi di Studio
**** Contatore accessi Web
- [[https://boystrange.github.io/LPP/HitCounter][Source]]
Relazione biunivoca tra IP e utenti unici in accesso

Java
#+begin_src java
public static int counter(InputStream stream) {
    Scanner scanner = new Scanner(stream);
    Set<String> clients = new HashSet<>();
    while (scanner.hasNextLine()) {
        String line = scanner.nextLine();
        String ip = line.substring(0, line.indexOf(' ') + 1);
        clients.add(ip);
    }
    return clients.size();
}
#+end_src
Bash
#+begin_src bash
cut -d' ' -f1 | sort -u | wc -l
#+end_src
Haskell
#+begin_src haskell
import Data.List (nub);
counter :: String -> Int
counter = length . nub . map (\line -> takeWhile (/= ' ') line) . lines
#+end_src
Java 8
#+begin_src java
public static long counter(InputStream stream) {
    InputStreamReader reader = new InputStreamReader(stream);
    return new BufferedReader(reader)
        .lines()
        .map(line -> line.substring(0, line.indexOf(' ') + 1))
        .distinct()
        .count();
}
#+end_src
