:PROPERTIES:
:ID:       3e9b697a-f7a8-4c9b-995d-da2d51202299
:ROAM_ALIASES: LPP
:END:
#+title: Linguaggi e Paradigmi di Programmazione
[[id:f956b52b-6fe3-4040-94e5-7474d1813a38][$university]]
Prof: Luca Padovani
* Info Corso
- Orario
  + Lun 16-18
  + Gio 9-11
  + Ven 16-18
- Testi
  + [[id:f46e95c3-14c2-4dda-b150-f8ca209495d1][Introduction to the Theory of Programming Languages]]
  + [[id:8f3dfc67-9e04-4cc6-8958-98559505065c][Haskell: the Craft of Functional Programming]]
  + [[id:dfb13901-7195-44df-843e-5601b65ad3b4][Programming in Haskell]]
  + Modern Java in Action
- Links
  +  https://boystrange.github.io/LPP/
- Esame
  + Esercizi di programmazione Haskell in tempo limitato
  + Teoria
    - Fondamenti del paradigma funzionale
  + Esercizi (Java 8) e Domande - 9 CFU


* Teoria
** Introduzione
Il paradigma funzionale mette le funzioni allo stesso livello delle variabili
- é possibile definire funzioni che trasformano funzioni, che restituiscono funzioni, che utilizzano funzioni in input
*** Paradigmi e Storia
- imperativo
  + C, Pascal
  + programma come sequenza di comandi da eseguire
    - l'esecuzione modifica lo stato della macchina ad ogni istruzione
- object-oriented
  + Smalltalk
  + oggetti che comunicano tra loro
    - permette di gestire piu' facilmente la complessita'
  + programma come interazioni (metodi) tra oggetti
    - le interazioni modificano lo stato della macchina
    - i metodi sono riconducibili al paradigma imperativo
- funzionale
  + Haskell
  + espressione valutazionale restituisce un risultato

Negli anni:
- '50
  + Assembly
  + FORTRAN
    - formula translator
    - procedure, espressioni
  + COBOL
    - per gestione aziendale, introduce il record
- '60
  + ALGOL
    - forma BNF
    - indipendente dall'architettura
    - blocchi, variabili locali, ricorsione
  + BASIC
    - facile da imparare ma poco strutturato
  + Simula 67
    - classi, oggetti, ereditarieta'
- '70
  + Pascal
    - programmazione strutturata, tipi per evitare errori
    - ideale per imparare a programmare
  + Smalltalk
    - programmazione ad oggetti estrema, tutto e' un oggetto
    - l'unica operazione possibile e' l'invio di messaggi, metodi
  + C
- '80
  + Ada
    - evoluzione di Pascal con concorrenza e tipi astratti
    - sviluppado dal ministero della difesa USA
  + C++
  + PostScript
    - scripting basato sullo stack, interpretato dalle stampanti
  + Perl
    - linguaggio interpretato
- '90
  + Python
  + Java
  + PHP
  + JavaScript
** \lambda-calcolo
Ci si restringe sull'essenza della programmazione in linguaggio funzionale
- si distilla un piccolo linguaggio facilmente studiabile

Differenze tra /linguaggio/ e /calcolo/
- il calcolo é *confluente*
  + il risultato non dipende dall'ordine delle azioni intraprese per raggiungerlo
    + in quanto le espressioni non possono modificare la memoria, non c'é memoria
- non é deterministico

*** Concetti
- processo di valutazione / =riduzione=
- funzioni con singolo argomento / =currificate= (Haskell Curry)
  + funzioni di ordine superiore
    * accettano come argomenti funzioni / restituiscono altre funzioni
  + agendo per specializzazioni
- linguaggi
  + =eager=
  + =lazy=
- Sistema di =Tipi= / Algoritmo di =Inferenza=
*** Funzioni
**** Punto di vista estensionale
$f = \{(0,1),(1,2),(2,5),\cdots\}$
**** Punto di vista intensionale
$f(x) = x^{2} + 1$
*** Sintassi
- Variabili
  + $Var = \{x,y,z.\cdots\}$
    * infinito
- Sintassi
  + $M,N ::= x \mid (\lambda x.M) \mid (M N)$
- Terminologia
  + $(\lambda x.M)$ astrazione o funzione con argomento $x$ e corpo $M$
  + $(M N)$ applicazione della funzione $M$ all'argomento $N$
- Esempi
  + $(\lambda x.x)$ - Funzione Identitá
  + $((\lambda x.(xx))(\lambda y.(yy)))$ - loop infinito
  + $(\lambda f.(\lambda x.(f(f x))))$

**** Convenzioni Sintattiche
- parentesi esterne omesse
- corpo delle astrazioni si estende a destra
  - a destra del punto
- l'applicazione é associativa a sinistra
**** Variabili Libere e Legate
- $x$ in $M$ é legata se compare in sotto-termine
- diciamo che un'occorrenza di $x$ in $M$ é libera altrimenti
Esempi
- $\lambda x.\: x$
  + nessuna variabile libera => termine chiuso
- $x \: y \: z$
  + tutte le variabili sono libere
- $(\lambda x.\: x \: y) \: x$
  + $x$ sia legata che libera
***** Sostituzione
- $M\{N/y\}$ é ottenuta sostituendo le occorrenze libere di $y$ in $M$ con $N$
- evitare la cattura delle variabili libere di $N$ per non alterarne il senso
  + le variabili libere sono definite esternamente allo scope della astrazione, non posso modificarle
*** Relazioni di Equivalenza
**** \alpha-conversione
$y \notin fv(M) \implies \lambda x.M \: \iff_{\alpha}\: \lambda y.M\{y/x\}$
congruenza tra \lambda-espressioni tali che hanno lo stesso corpo, solo con nome dell'argomento diverso
**** \beta-riduzione
_Applicare_ una funzione $\lambda x.M$ a un argomento $N$ significa valutare il corpo in cui ogni occorrenza libera dell'argomento $x$ é sostituita con $N$.
$(\lambda x.M) \: N \rightarrow_{\beta}M\{N/x\}$
- $M \rightarrow_{\beta}M^{'} \implies M \: N \rightarrow_{\beta}M^{'}\:N$

Da =redex= (reducible expression) a =ridotto=
- $(\lambda x.M) \: N$
- $M\{N/x\}$
**** \eta-riduzione
$x \notin fv(M) \implies \lambda x.M \: x \rightarrow_{\eta}M$
- $M \rightarrow_{\eta}M^{'} \implies M\: N \rightarrow_{\eta}M^{'}\: N$
- $M \rightarrow_{\eta}M^{'} \implies N\: M \rightarrow_{\eta}N \: M^{'}$
- $M \rightarrow_{\eta}M^{'} \implies \lambda x.M \rightarrow_{\eta} \lambda x.M^{'}$
**** Convertibilitá
$N\rightarrow M \land M\rightarrow N  \implies M \leftrightarrow N$
- $\Leftrightarrow$ indica la chiusura riflessiva e transitiva di $\leftrightarrow$
**** Confluenza
*Teorema*:
- $M \Rightarrow N_{1} \land M \Rightarrow N_{2} \implies \exists N \mid N_{1} \Rightarrow N \land N_{2} \Rightarrow N$
- l'ordine delle riduzioni del \beta-redex non importa
- il teorema si generalizza in $n$ $N$
Questo risultato é importante in quanto non risulta per nessun altro linguaggio di programmazione
- in quanto la memoria puó essere modificata dall'esecuzione, l'ordine diventa fondamentale
  - al contrario del lambda calcolo che é un /linguaggio puro/
    - come =Haskell=, nella sua versione piú pura
- /Es/: l'assegnamento é una espressione mista, sia espressione sia un comando
***** Forma Normale
Un =M= é in forma normale se non puó piú essere ridotto, ovvero:
- $\nexists N \mid M \rightarrow N \implies M \nrightarrow$
Un termine in forma normale ci indica che _la computazione é finita_
***** Corollario
La forma normale di =M=, se esiste, é unica (a meno di \alpha-conversioni).
**** Strategie di Riduzione
In alcuni casi é piú efficiente l'uno, in altri l'altro
***** Ordine Applicativo
redex piú a sinistra e piú interno, *linguaggi zelanti*
=(\lambda x.x)((\lambda y.y)z) -> (\lambda x.x)z -> z=
=.      ----------     --------=
- applicare una funzione a un argomento signifira prima valutare l'argomento poi sostituire nel corpo della funzione
***** Ordine Normale
redex piú a sinistra e piú esterno, *linguaggi pigri*
=(\lambda x.x)((\lambda y.y)z) -> (\lambda y.y)z -> z=
=-----------------     --------=
- applicare una funzione a un argomento significa sostituire l'argomento nel corpo della funzione
  + si posticipa la valutazione degli argomenti fino a che non é strettamente necessaria

Ottimizzabile in caso di argomenti valutati piú volte
- si memorizza il risultato parziale, in modo da non doverlo ricalcolare multiple volte
  + questo é sicuro se il linguaggio é puro
  + molto delicato da utilizzare in contesti diversi
  + simile alla tecnica di /memoizzazione/

***** Teorema Normalizzazione
Se $M \Leftrightarrow N$ é normale, allora c'é una riduzione in ordine nomale $M \Rightarrow N$
- se la forma normale di un'espressione esiste, la posso trovare riducendo l'espressione in ordine normale
  + in un numero finito di passi
- questa proprietá non vale per l'ordine applicativo
  + potrebbe finire in un loop nel cercare di risolvere subito gli argomenti
*** Programmare nel \lambda-calcolo
**** Booleani
=TRUE = \lambda x.\lambda y.x=
=FALSE = \lambda x.\lambda y.y=
=IF = \lambda z.z=
=AND = \lambda x.\lambda y.IF x y FALSE=
=OR = \lambda x.\lambda y.IF x TRUE y=
=NOT = \lambda x.\lambda y.IF x FALSE TRUE=
* Laboratorio
** Haskel
*** Storia
- $\lambda$ calcolo
  + Alonzo Church
    - calcolare con le funzioni, cosí come con in numeri
    - tutto é una funzione con 1 IN e 1 OUT
      + funzioni anonime
        - identitá
          + $\lambda x,x$
  + Haskell Curry
    - curring
- LISP - anni '50
  + John McCarthy
    - elaborazione informazione non-numerica/simbolica
    - LISP = List Processor
      + cons e map nascono qui
    - primo _garbage collector_
- ML
- SASL, KRC, Miranda
  + linguaggi _lazy_ con valutazione solo al momento della richiesta della funzione
  + SASL introduce guardie e currying
- Haskell - anni '90
  + linguaggio lazy, standardizzato
  + separazione tra puro e impuro
    - monadi
  + overloading
  + grosso impatto sul calcolo parallelo
*** Casi di Studio
**** Contatore accessi Web
- [[https://boystrange.github.io/LPP/HitCounter][Source]]
Relazione biunivoca tra IP e utenti unici in accesso

Java
#+begin_src java
public static int counter(InputStream stream) {
    Scanner scanner = new Scanner(stream);
    Set<String> clients = new HashSet<>();
    while (scanner.hasNextLine()) {
        String line = scanner.nextLine();
        String ip = line.substring(0, line.indexOf(' ') + 1);
        clients.add(ip);
    }
    return clients.size();
}
#+end_src
Bash
#+begin_src bash
cut -d' ' -f1 | sort -u | wc -l
#+end_src
Haskell
#+begin_src haskell
import Data.List (nub);
counter :: String -> Int
counter = length . nub . map (\line -> takeWhile (/= ' ') line) . lines
#+end_src
Java 8
#+begin_src java
public static long counter(InputStream stream) {
    InputStreamReader reader = new InputStreamReader(stream);
    return new BufferedReader(reader)
        .lines()
        .map(line -> line.substring(0, line.indexOf(' ') + 1))
        .distinct()
        .count();
}
#+end_src
*** Caratteristiche Linguaggio
**** Guardie
Introducono delle condizioni, alternativa al piú operazionale =if...then...else=
#+begin_src haskell
assoluto :: Int -> Int
assoluto n | n >= 0 = n
           | n < 0  = negate n
#+end_src
Nel caso che i casi siano _esaustivi_ l'ultimo identificatore puó essere =otherwise=
L'ordine delle guardie é significativo, sará scelta la prima guardia il cui valore sia valutato =True=
**** Ricorsione
Non esistono /loop/ non esistendo la memoria, e quindi variabili su cui fare iterazione.e
É quindi necessario utilizzare le definizioni ricorsive:
#+begin_src haskell
fattoriale :: Int -> Int
fattoriale n | n == 0    = 1 -- supponendo n >= 0
             | otherwise = n * fattoriale (n - 1)
#+end_src

Si possono specificare piú equazioni, semplificando il codice
#+begin_src haskell
fattoriale :: Int -> Int
fattoriale 0 = 1 -- lo 0 fa riferimento al parametro utilizzato
fattoriale n = n * fattoriale (n - 1)
#+end_src

Altro esempio classico, la sequenza di fibonacci
#+begin_src haskell
fibonacci :: Int -> Int
fibonacci 0 = 0
fibonacci 1 = 1
fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
#+end_src
Anche usando questa forma Haskell valuta le funzioni dall'alto verso il basso, nell'ordine.
- i pattern piú generali vanno piú in basso, =Haskell= in caso emette un ~Warning~ riguardo la ridondanza dei match non raggiungibili
*** Funzioni Anonime
_\lambda-Astrazioni_
#+begin_src haskell
(\x -> x+1) 2
(\x -> x >= 0) 2
#+end_src
In Haskell, si dice *sezione* un'espressione racchiusa tra parentesi in cui un operatore binario viene applicato a uno solo dei suoi due argomenti.
#+begin_src haskell
(1 +)
('mod' 2)
#+end_src
*** Currying
#+begin_src haskell
addizione :: Int -> Int -> Int
addizione x y = x + y
addizione = \x -> \y -> x + y -- espandendo in lambda astrazioni é piú chiaro il tipo
#+end_src
Da qui emerge l'associativitá a destra del tipo freccia:
#+begin_src haskell
(Int -> (Int -> Int))
#+end_src
Questo é speculare alla composizione in lambda calcolo

_Applicazione parziale_: Il fatto che tutte le funzioni sono ad un unico argomento permette di crearne *specializzazioni* applicandole a meno argomenti del necessario.
- posso applicare solo parzialmente funzioni se mi puó essere utile
