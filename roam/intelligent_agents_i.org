:PROPERTIES:
:ID:       54623d0e-8f4b-44c7-9de5-902f6fad6d7a
:END:
#+title: Intelligent Agents I
#+date: [2023-02-27 Mon 10:55]
#+FILETAGS: erasmus university compsci

* Agent
- interacts with an /environment/
  + could be anything
  + has *perception* of this environment (sensors)
  + can take *action* based on this perception (actuators)
- *reasoning* takes the agent from perception to action
  + this is the aspect studied in this course

* Classical Logic
- propositional logic
- first order logic

Can't classical logics be used?
- the problem is the information we have is not purely mathematical
- how do you model *Knowing*
  + $\text{Knowing}(X,Y)$
  + problem of extensionality
    - knowledge is not extentional
      + knowing something that is true *does not mean* knowing everything that is true
      + in =CL= true formulas are equivalent
  + facts can be inconsistent
    - $A$ is the case *and* $\lnot A$ is perceived $\implies$ anything
      + false implies anything
      + *principle of explosion*
  + monotone logic is not what we want
    - in implications we can add anything to the left side and the right will still hold
    - does not model exceptions to a rule
- *material implication* is not intuitive and does not make sense in real world applications

So the =CL= need to be extended to allow for reasoning in real world context.

* Logics
** Modal Logics
=ML=
*** Syntax
- alphabet
  + connectives
  + propositional symbols
  + parenthesis
  + 2 new connectives
    - $\square \quad \diamond$
- formula
  + $p \in PS | A \land B | ...$

The /box/ and /diamond/ can be interpreted as:
- depends of the context
- alethic logic
  + $\square A$ - necessarily $A$
  + $\diamond A$ - possibly $A$
- doxastic logic
  + $\square A$ - $A$ is believed to be true
- epistemic logic
  + $\square A$ - $A$ is known
*** Modal
/Qualifies the truth of a statement/
- can qualify if the truth is temporally qualified or necessarily qualified etc.
*** Epistemic Logics
- equivalence relations
- common knowledge
  + adds induction in the language
- everyone knows
- updates with public announcements
  + reduction
*** Temporal Logics
- order relations
  + total order
  + partial order
- until
  + something holds until something else holds
  + binary operation
- quantification with $A$, $E$

Properties about
- assertions that
  + might hold in the future
  + held in the past
  + will hold eventually

Used for reasoning about temporal aspects in natural language, evolution in multi-agents systems, formal methods reasoning and verification

From a computation point of view the easiest way to think about time is one that is
- backward-linear, branches in the future
  + partial order
  + can be a decision tree
  + can be a probabilistic tree
- discrete

Operators:
- Next: $X\phi$, sometimes a $\circ \phi$
  + accessible worlds
  + not transitive
- Globally: $G \phi$
  + all worlds in the future
  + transitive
- Future: $F\phi$
  + holds eventually
- Until: $\phi U \psi$, can be strong on weak (inclusive or not)
  + $\phi$ holds until $\psi$ holds
  + $\psi$ holds in the future
  + $\phi$ holds until the moment in the future where $\psi$ holds
    - $\lnot \psi \land \phi \to \lnot \psi \land \phi \to \psi \land \lnot \phi$

- safeness properties
  + something bad never happens, uses $G$
- liveness properties
  + something good eventually happens (infinitely often)
  + uses $G$ and $F$
**** Linear temporal logics
=LTL=
- prop symbols
- negation
- conjunction
- $X$
  + its the same as $\square$ and $\diamond$ but being linear now they are the same
- $U$
We can define
- $F$ is the tautology of $F \phi = \text{T} U \phi$
- $G$ is defined as the dual of future $G \phi = \lnot F \lnot \phi$

The set of worlds represent the infinite set of time instants.
For the semantics we define $\lambda$ as the possible worlds model
- can think about the trace a system
- used to simplify notation of the accessibility relation $R$ (which is a total order)
- access a point (world) in the sequence as $\lambda(i) = w_i$
- have a new /trace/ starting from $i$ with $\lambda^i = w_i w_{i+1} w_{i+2}\cdots$
**** Computation Tree logic
=CTL=
We want to talk about partial orders.
It is an extention of =LTL=, temporal operators and path quantifiers.
- path formulas
- state formulas

** Proof Systems
*** Hilbert style
A *Hilbert style* proof system is more difficult to use as it requires creativity.
You start from any tautology and with it's rules it generates all true statements, this is elegant but it is not good for proof search. It is a so called *synthetic* proof system.
On the other hand a *Gentzen system* you start from the formula you want to prove and it is an *analytic* and *sequential*. It has a decision procedure, it is applicable by machines.

It is very small with only 2 axioms and 3 rules for the $K$-proof.
Axioms:
- K
- Dual
Rules:
- Modus Ponens
- Uniform substitution
- Generalization/Necessitation

*NB* in Hilbert systems you cannot use assumptions as input to generalization.
*** Semantic Tableaux
*Semantic Tableaux* is a indirect proof system, *analytic* (so it's similar to sequent calculus).
- formulas are prefixed by numbers
  + i.e. =1.1.2,1=
- root is =1.=
  + to try and prove $A$ then the root is the negation $\lnot A$
- application of tableaux rules build the tree
- branch gets closed =iff= a formula and its negation both occur in it
- $A$ is proven when each branch is closed
  + if all rules have been applied but there is still an open branch $A$ cannot be proven
- it is *sound and complete*

**** Inference rules
Prefix is indicated by $\sigma$.
The whole idea is to simplify formulas by removing connectives.
The | is the representation of the tree. It creates two branches where one side is true or the other is.
The reasoning is by cases and proceeds by proving contradictions (closing the branch) in all these cases.

** Multi-agent Logics
Express the individual knowledge.
