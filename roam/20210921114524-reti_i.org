:PROPERTIES:
:ID:       dbb7c5e0-6782-48ac-bf11-4c163747cf37
:END:
#+title: Reti I
[[id:f956b52b-6fe3-4040-94e5-7474d1813a38][$university]]
* Info Corso
- Prof:
  + Marco Botta
- Orari:
  + Mar 16-18
  + Mer 16-18
  + Gio 11-13 (in alternativa a [[id:6e332ccc-6881-4fff-a9e9-fd1f14286559][ProgIII]])
- Testo:
  + [[id:76b7b469-bc51-4cd7-8386-779fc351552c][Computer Netwoking - A Top-Down Approach]]
* Teoria
** Introduzione alle Reti di Calcolatori
/Internet come esempio delle reti/
*** Componenti
- Computing Devices connessi
  + hosts / sistemi terminali
    - alla periferia della rete
    - eseguono degli applicativi
      + applicazioni di rete
  + links
    - wireless
    - wired
  + router
    - collegati tra di loro
    - collegati agli hosts
      + permettono a questi di comunicare a grandi distanze
      + _packet switching_
- Gerarchia
  + Internet come rete di reti
  + home Network
    - Regional ISP
      + Global ISP
        - mobile Network
    - Institutional Network

In sostanza:
- hosts: clients, servers / dispositivi periferici alla rete / _edge networks_
  + in prevalenza wireless
  + _access network_ punto di accesso
    - per connettere terminali si utilizzano /router di frontiera/
    - reti di accesso residenziale/istituzionale/mobile
- routers in profonditá nella rete / _core network_
  + in prevalenza wired

**** Accesso
***** Digital Subscriber Line
=DSL=
Utilizza linee telefoniche esistenti
- splitter
  + dati vanno su Internet
  + voce va sulla rete telefonica
La linea é asincrona:
- Up < 1Mbps
- Down < 10Mbps
  + poiché questa é la piú utilizzata generalmente
Collegato direttamente alla Centrale
***** Cable Network
Via cavo, utilizzata dagli anglosassoni
- cavo condiviso da vari utenti
- cable modem
  + collegato da uno splitter
    - dati vanno su Internet
    - segnale televisivo va su TV
    - vengono utilizzate tecniche di multiplexing
- Hybrid fiber coax
  + Up < 2Mbps
  + Down < 30Mbps
A differenza della DSL non ha un collegamento diretto al centtrale

***** Enterprise Access Network
Ethernet, sono dei Router che fanno parte della rete internet del ISP
- institutional router
  + Ethernet switch
    - connessioni singole
- Velocitá: 10Mbps, 100Mbps, 1Gbps, 10Gbps
***** Wireless Access Network
- LAN:
  + 100ft
  + 802.11 b/g: 11Mbps, 54Mbps
- Wide-Area
  + telco operator, 10km
  + 1 - 10 Mbps
    - 3G, 4G, LTE
**** Host
Invio di pacchetti di dati tra gli Host
pacchetti di bit di lunghezza $L$, trasmissione a velocitá $R$
- packets
- link bandwidth
Packet Transmission Delay = $\frac{L}{R}$
**** Mezzi Trasmissivi
- guiditati
  + il segnale segue un percorso ben preciso
  + cavi
    - Twisted Pair (TP)
      + 2 cavi di rame intrecciati
    - Coaxial Cable
      + 2 cavi di came concentrici
      + maglia di rame intorno per schermare
      + cavo interno biderezionale banda langa
    - Fiber Optic
      + fibre di vetro all'interno della quale passa la luce
      + il segnale é luminoso, ogni bit é un impulso luminoso
      + molto flessibili
      + molto veloci, immune alle interferenze elettromagnetiche
        - tasso di errore molto basso
- non guidati
  + onde radio
    - segnali trasportati nello spettro elettromagnetico
    - possono essere riflessi, ostruiti, interferiti
    - Microonde terresti
      + < 45Mbps
    - LAN WiFI
      + < 11 - 54Mbps
    - Wide-Area
      + 3G, 4G
    - satellitare
      + delay per la distanza con il satellite
      + da Kbps a Mbps
**** Nucleo della Rete
Packet Switching preferito perché permette a piú utenti di usare la rete contemporaneamente
- questo in quanto é bassa la probabilitá che tutti gli utenti siano attivi contemporaneamente
**** Packet Switching
:PROPERTIES:
:ID:       279faeb3-247c-4b7e-8521-a8a7959bdf11
:END:
Router Interconnessi che comunicano usando il packet switching
- ogni pacchetto ha lo stesso formato e dimensione, semplici da _smistare_ verso la destinazione
- ogni pacchetto usa l'intera capacitá del collegamento per essere inviato

_Store-And-Forward_
- il router deve ricevere almeno parte del pacchetto, supponiamo tutto
- solo allora puó decidere su quale collegamento in uscita trasmetterlo
_Queuieng and Loss_
- in uscita solo un pacchetto puó passare per volta
  + si formano delle code nel ~buffer~ del router
  + se la coda é piena un nuovo pacchetto viene scartato

- Funzioni principali del Nucleo
  + routing - instradamento
    - Routing Algorithm
      + determina il cammino che i pacchetti dovranno seguire
    - Local Forwarding Table
  + forwarding - inoltro
    - copia sull'uscita scelta il pacchetto

Piú semplice del circuit switching, i router non devono attivarsi per creare la connessione, ma condividendo le risorse possono crearsi congestioni
- puó essere garantita banda ad alcune app audio/video per ottenere del comportamento simile al circuit switching

***** Circuit Switching
Creare un collegamento diretto tra mittente e destinatario
C'é una ridondanza di collegamenti tra i router
- a seguito di una richiesta i router aprono e chiudono i circuiti per creare una linea diretta di circuiti
- con questo schema non ci sono risorse condivise a differenza del Packet Switching
  + i pacchetti andranno alla massima velocitá possile
  + un circuito non utilizzato puó essere considerato uno spreco
****** FDM
****** TDM
*** Protocolli
Skype, TCP, IP, HTTP, 802.11
Definiscono:
- formato,ordine di messaggi ricevuti e mandati
- azioni intraprese su invio e ricevuta di messaggi
*** Internet Stardards
- RFC: Request for comments
- IETF: Internet Engineering Task Force
  + ente che valuta e accetta standard di comunicazione
*** Packet Delay
:PROPERTIES:
:ID:       21e709d3-7471-45e0-9194-16df2ecb30f1
:END:
$d_{nodal} = d_{proc} + d_{queue} + d_{trans} + d_{prop}$
- processing
- queue
  + dipende dalla congestione
- transmission
  + dipende dalla velocitá
  + $L/R$
- propagation
  + $d/s$
  + $d$: lunghezza del collegamento
  + $s$: velocitá di propagazione nel medium
    + $2e8$ m/sec
Se il buffer é pieno il packetto é perso (/packet drop/)
$\frac{L\cdot a}{R}$ = traffic intensity
$a$ é la quantitá media di pacchetti in entrata
quando questa frazione supera 1 i bit in entrata superano la capacitá trasmissiva, i buffer si vanno a riempire
**** Packet Loss
Il buffer (coda) é piena, un pacchetto é perso, viene comunicato al router precedente/alla sorgente/viene ignorato
*** Throughput
due casi:
1. $R_{S}<R_{C}$
2. $R_{S}>R_{C}$
Throughput, la quantitá minima
- compreso il /bottlenoek link/
*** Servizi
Internet puó essere definito come infrastruttura di servizio ad applicativi
- che ne hanno bisogno per comunicare tra loro
Internet puó anche fornire un'interfaccia di programmazione utile alla comunicazione
- Generalmente:
  + server
    - fornisce un servizio
  + client
    - accede a servizi
Ma la divisione non é netta, ogni Computer puó essere entrambi

L'ISP fornisce una certa bandwidth
- che dipende anche dal proprio PC, che potrebbe fare bottleneck

*** Storia
- 1961: Kleinrock
  + queuing theory dimostra l'efficacia del packet-switching
- 1964: Baran
  + packet-switching in reti militari
- 1967: ARPAnet
  + dell'Advanced Research Project Agency
- 1969
  + attivazione primo nodo ARPAnet
- 1972
  + prima vera rete ARPAnet, posta elettronica
- 1970: ALOHAnet
- 1974: Cerf and Kahn
  + architettura di interconnessione delle reti
  + principi alla base dell'architettura odierna
    - minimalismo
    - autonomia
    - controllo decentralizzato
    - best effort service model
    - dispositivi stateless
- 1976: Xorox
  + Ethernet
- 1979: ARPAnet ha 200 nodi

Proliferano Reti e Protocolli:
- 1983: TCP/IP
- 1982: smtp e-mail
- 1983: DNS
- 1985: ftp
- 1988: controllo congestioni TCP

Commercializzazione e World Wide Web
- 1990~: ARPAnet decommisionata
- 1990~: Web
  - Berners-Lee
    - HTTP, HTML
- 1994: Mosaic, poi Netscape

** Livelli
*** Livello Applicativo
Applicazioni su terminali, permettono uno sviluppo e propagaziose software molto veloce
- il software non si occupa dei dettagli implementativi della comunicazione web
**** Concetti delle Implementazioni
Esistono strutture diverse per le applicazioni
- client-server
  + server - attende richieste
    * host sempre acceso
    * IP permanente
    * data centers
  + client - invia richieste
    * comunicano con il server
    * puó essere connesso periodicamente
    * puó avere IP dinamico
    * non comunicano direttamente tra loro
- peer-to-peer
  + non esiste un server sempre attivo
  + i peer possono comunicare direttamente
  + i peer richiedono servizio ad altri peer che li fornincono
  + auto-scalabile

I processi inviano/ricevono messaggi attraverso i =socket=
- analogo ad una porta
- il percoso e il trasporto é lasciato ai livelli sottostanti

Per ricevere i messaggi i processi devono avere un _identificatore_
- l'host ha un IP unico, ma non basta
  + possono esserci tanti processi in esecuzione
- IP-host + port number
  + HTTP server: 80
  + mail servel: 25

**** Protocolli di Livello Applicativo
Definiscono
- tipo dei messaggi
- sintassi dei messaggi
- semantica dei messaggi
- regole per quando si inviano messaggi e si risponde

Due tipologia
- open protocols
  - RFC liberamente consultabili
  - permettono interoperabilitá
- proprietary protocols

***** Integritá dati
Alcune applicazioni non necessitano dati al 100% corretti
Altre necessitano della completa integritá dei dati

***** Tempi di comunicazione
Alcune applicazioni necessitano una certa temporizzazione, delay basso

***** Throughput
Alcune applicazioni necessitano un minimo throughput da mantenere per funzionare
- multimedia
- a differenza di file-transfer
  + elastic app

***** Sicurezza
Criptazione dei dati, integritá dei dati

***** TCP
- reliable transport
- flow control
- congestion control
- no
  + timing
  + security
  + minimum throughput
- connection-oriented
***** UDP
- unreliable data transfer
- no
  + reliability
  + flow control
  + timing
  + security

Non fornisce servizi particolari, é utilizzato per esempio da applicazioni multimediali
- permette di inviare dati alla stesso velocitá a cui il mittente li puó inviare

***** HTTP
=HyperText Transfer Protocol=
- pagine = insieme di oggetti
- pagine che hanno riferimenti ad altri oggetti
  - identificati URL

- client: browser
- server: web server

Utilizzando TCP
- lato client inizializza connessione creando socket su client e connettendosi alla porta 80 sul server

HTTP é /stateless/
- non mantiene informazioni riguardo le passate connessioni
- questo perché un protocollo con stato é molto complesso

- /non-persistent/
  + al massimo 1 oggetto viene inviato su TCP
    + poi si chiude
  + si deve aprire una nuova connessione per ogni UL/DL
  + =RTT= tempo di andata e ritorno per dati dal client al server
    + puó essere calcolato dal client con questa definizione

- /persistent/
  + viene mantenuta la stessa connessione TCP per un periodo
  + puó velocizzare leggermente la comunicazione
  + 1.0

- Metodi
  + POST
    * web page include input
  + URL

- differenze versioni
  + 1.0
    * GET
    * POST
    * HEAD
  + 1.1
    + precedenti
    + PUT
    + DELETE
****** Status Codes
- 200 OK
- 301 Moved Permanently
- 400 Bad Request
- 404 Not Found
- 505 HTTP Version Not Supported
****** Cookies
Dato che il protocollo é /stateless/ i cookies sono utilizzati per memorizzare alcune informazioni
- 4 componti
  + header HTTP response
  + header HTTP request
  + cookies mantenuti sulla memoria del browser
  + DB backend sito Web
Utilizzati per
- mantenere autorizzazioni
- carrelli della spesa
- pubblicitá targettizzata
- sessione Web utente (email)
****** Web Caches
Per fornire all'utente ció che richiede senza interagire direttamente con il server d'origine
- una richiesta giá fornita puó essere risolta da un /proxy server cache/
  + solitamente installati dalle ISP
  + riduce il carico sul link di accesso
    + secondo un suo /hit rate/
- lo stesso browser inserisce gli oggetti ricevuti in cache
****** Conditional GET
Per controllare che gli oggetti ricevuti siano aggiornati
- le cache fanno C.GET al server
  + la risposta non contiene nessun oggetto se la versione in cache sia aggiornata

***** FTP
=File Transfer Protocol=
- TCP, per trasferimento affidabile
- client-server
- porta 20-21
- Richiede autenticazione
  + primo TCP - client puó navigare il filesystem remoto
    * chiusa alla fine della comunicazione
  + secondo TCP - dopo file transfer command il server apre connessione (porta 20)
    * chiusa alla fine della trasmissione del file
- control connection: /out of band/
  + 2 canali diversi
- il server FTP mantiene lo stato
  + directory corrente
  + autenticazione utente

****** Comandi e Codici
Comandi
- USER username
- PASS password
- RETR filename
- STOR filename
- CD directory
Codici di ritorno
- 331 Username OK, password required
- 125 data connection already open
- 425 Can't open data connection
- 452 Error writing file

***** SMTP
=Simple Mail Transfer Protocol=
3 componenti
- user agents
  + client
  + interfaccia utente
- mail servers
  + i messaggi in uscita e in entrata vengono memorizzati qui
- SMTP
  + utilizzato nella comunicazione diretta tra i mail server, o dai user agents ai server

Specifiche:
- porta 25
- trasferimento diretto dei messaggi _tra i server_
- 3 fasi
  + handshake
  + transfer
  + closure
- comandi/risposte
  + ASCII
  + Status code & frase descrittiva
- messaggi in ASCII 7-bit
- connessioni _persistenti_
- protocollo di tipo /push/
  + invia dati al server, al contrario di =HTTP=
- oggetti multipli fanno _parte dello stesso messaggio_
  + mentre =HTTP= incapsula ogni oggetto all'interno di una risposta ognuno
***** POP3
- authorization phase
  + user, pass
  + OK, ERR
- transaction phase
  + list, retr, dele, quit
***** DNS
=Domain Name System=
/protocollo di Livello Applicativo/
- Internet hosts router
  + IP address 32 bit
  + nome simbolico leggibile
- =DNS= si occupa di mappare IP a nome e viceversa

****** Specifiche
- database _distribuito_
- host e name server comunicano per risolvere i nomi in IP
- é implementato come _Application-Layer_
  + la complessitá é lasciata ai sistemi terminali
    * se fosse centralizzato sarebbe l'unico punto di fallimento, database singolo e lontano, grande traffico, manutenzione complessa e costosa
- _distribuisce il carico_
  + indirizza il client che fa la richiesta verso l'indirizzo IP meno carico di richieste tra quelli disponibili

Il sistema é distribuito e gerarchico
- com /DNS servers/
  + yahoo.com /DNS serves/
  + ...
- org /DNS servers/
  + pbs.org /DNS servers/
- edu /DNS servers/
  + poly.edu /DNS servers/
****** Gerarchia
******* Root
I server DNS radici sono 13, in tutto il mondo
 - interrogati solo se uno dei server sottostanti non riesce a risolvere il nome
******* TLD
=Top Level Domain=
com, org, net, edu, jobs, uk, it, fr
Educause e Network Solution gestiscono questi domini
******* Authorative DNS
=DNS= propri delle organizzazioni pubbliche e private
******* Local DNS
Non appartengono strettamente alla gerarchia
- ogni ISP ne ha uno
- quando l'host fa una query questa é inviata a questo =DNS=
  + gestito localmente
  + se non puó risolvere l'indirizzo agisce come proxy e risale la gerarchia
    + la query puó essere /ricorsiva/ o /itecativa/
****** Caching
Una volta risolto un indirizzo il servel lo memorizza
- timeout, per evitare associazioni obsolete - ~TTL~
  + /time to leave/
- tipicamente la cache é mantenuta nei DNS locali
****** Resource Records
=RR=
=(name, value, type, ttl)=
- tipi
  - ~A~
    * name = hostname
    * vasue = IP
  - ~CNAME~
    * name = sinonimo
    * value = hostname / nome canonico
  - ~NS~
    * name = domain
    * value = hostname del Authorative DNS
  - ~MX~
    * name = nome
    * value = mailserver
****** Messaggi
- header
  + identification
  + flags
    * query or reply
    * recursive or not
    * recursion available
    * reply authoritative
- questions
  + name, type
- answers
  + RRs
- authority
- info

**** Architetture
***** Client-Server
***** P2P
=Peer to Peer=
Non esiste un server sempre attivo

Utilizzato in
- condivisione di file
  + BitTorrent
    + file diviso in /chunks/ dal server e distribuiti in rete
    + i peer condividono tra loro (torrent)
    + *tracker*
      * tiene traccia dei /chunks/ dei peer
      * registra i peer
    + *tit-for-tat*
      * ci si scambia /chunks/ dai peer piú vicini, piú a contatto
      * ogni 30 secondi si selezionano peer random
- VoIP
- streaming
Qualunque Peer é un pari, ognuno di essi puó condividere risorse
******* Skype
Inerentemente =P2P=
Server:
- gestisce login
- mette in contatto i peer
Clients
- mappati sui SuperNodi
  + username =->= IP

Peer riflettori - /relays/
- I =NAT= non permettono connessione diretta tra i clients
- i supernodi fanno da /relay/
  + i supernodi tra loro comunicano
  + aprono una connessione tra i dispositivi

**** Programmazione Socket
- Socket - operato dallo sviluppatore
  + porta tra processo e protocollo di trasporto end-to-end
- TCP - operato dal =OS=
  + buffer
  + variabili
- UDP
  + non c'é connessione tra client e server
    * questi si scambiano solo messaggi
  + i dati possono perdersi o essere consegnati in ordine diverso a quello di invio

*** Livello di Trasporto
/Comunicazione logica tra processi/
- affidabile, consegna ordinata
  + *TCP*
- non affidabile, consegna disordinata
  + *UDP*
**** Multiplexing
- Multiplexing mittente
  - aggiunge _transport header_
- Demultiplexing ricevente
  * riceve /IP datagramma/
  * con IP mittente e IP destinatario
  * con numero di porta mittente e destinatario
**** TCP
- 4-tupla
  + source IP
  + source port number
  + dest IP
  + dest port number

***** Caratteristiche
- /point-to-point/
- /reliable/, in-order byte stream
- /full duplex data/
- /pipelined/
  + congestion e flow control impostati a window size
  + =ACK= cumulativi
    * del pacchetto che si aspetta di ricevere
- /connection-oriented/
  + handshaking
- /flow controlled/

***** Segmento
- campi da 32 bit
  + source port # | dest port #
  + sequence #
  + =ACK= #
  + head len | not used | U | A | P | R | S | F | receive window
  + checksum | urg data pointer
- campi a lunghezza variabile
  + options
  + application

***** Timeout
- piú lungo del =RTT= - /Round Trip Time/
  + ma puó variare
- corto
  + trasmissioni non necessarie
- lungo
  + trasmissione _poco reattiva_ a packet-loss
- Si stima =RTT=
  + tempo dalla trasmissione alla ricezione =ACK=
  + si fa una media dei =Sample=
    * $RTT_{\text{est}} = (1-\alpha)\cdot RTT_{\text{est}}+\alpha\cdot \text{Sample}$
      - dove solitamente $\alpha = 0.125$
    * $\textsc{Dev}_{\textsc{rtt}} = (1-\beta) \cdot \textsc{Dev}_{\textsc{rtt}} + \beta \cdot |\text{Sample}-RTT_{\text{est}}|$
      - dove solitamente $\beta = 0.25$
      - _margine di sicurezza_
  + $\text{TimeoutInterval} = RTT_{\text{est}} + 4\cdot \textsc{Dev}_{\textsc{rtt}}$
- timer impostato sul pacchetto piú vecchio di cui non si é ricevuto =ACK=

***** ACK
- vari scenari per ridurre il numero di =ACK=
***** Fast Retransmit
- 3 =ACK= duplicati indicano che probabilmente un segmento é andato  perso
- non aspettare il timer ma ritrasmetti immediatamente il segmento /unacked/

***** Connection Management
- handshake
  + si decide di stabilere la connessione
  + si decidono i parametri di comunicazione
- socket buffer, variabile
  + comunicato dal ricevente
Listen \rightarrow SYN sent \rightarrow Established
Listen \rightarrow SYN received \rightarrow Established
****** Congestion Control
=TCP= é un protocollo /fair/ rispetto alle connessioni e le loro capacitá trasmissive
Troppe sorgenti che inviano dati ad una velocitá superiore a quella gestibile dalla rete
- pacchetti perse per buffer overflow ai router
- lunghi ritardi in coda ai buffer dei router

Con conoscenza perfetta il mittente invierebbe solo quando il router ha spazio libero in buffer, questo ovviamente non puó avvenire.
Anche se si sapesse prima che il pacchetto é perso per buffer pieno il mittente reinvia
Le _ritrasmissioni_ sono il prezzo da pagare per avere un buon throughput

Due approcci:
- /end-end/
  + congestione inferita dalla perdita e ritardo osservati dai terminali
    * cambiando la finestra di trasmissione =cwnd=
  + usato da =TPC=
    * /additive increase multiplicative decrease/
      - cresce linearmente, limitata dividendo per 2
    * mittente incrementa =cwnd= fino a quando rileva perdita
    * /slow start/
      - fino alla prima perdita aumenta =cwnd= esponenzialmente
    * reazione alla perdita
      - timeout
        + finestra di trasmissione torna a 1
        + /slow start/ fino a threshold
      - 3 ACK duplicati (uguale al timeout in =TCP= Tahoe)
        + finestra di trasmissione dimezzata (=TCP= RENO)
- /network-assisted/
  + router danno feedback ai terminali
  + bit che indica congestione
  + esplicita una frequenza di trasmissione per il mittente
  + =ATM ABR=
    * servizio elastico
      - se il cammino é congestionato il mittente viene limitato
      - se il cammino é libero il mittente viene avvantaggiato
    * celle Resource Manager
      - mandate assieme alle celle dei dati
      - contengono informazioni sulla congestione
      - restituiti al mittente dal ricevente con i bit intatti

Le app di multimedia non usano =TCP= per evitare il throttling dovuto al congestion control, tollerano il packet loss.

**** UDP
=User Datagram Protocol=
- bare bones
- best effort
  + i segmenti possono essere persi
  + consegna disordinata
- *connectionless*
  + niente handshaking
  + ogni segmento é gestito indipendentemente
- usi
  + streaming
  + DNS
  + SNMP
Non avendo connessione iniziale é piú veloce, non ha limiti di congestion control, header piccoli.

- gestione errori
  + UDP checksum
    * mittende e destinatario calcolano la checksum e la confrontano

**** RDT
=Reliable Data Transfer=
- 1.0
  - channel sottostante perfettamente affidabile
  - =FSM= separate per sender / receiver
- 2.0 - /errors/
  * channel sottostante puo' invertire bit
    - checksum
  * =ACK=
    - receiver comunica al sender OK
  * =NAK=
    - receiver comunica al sender che si hanno errori
    - sender ritrasmette
- 2.1
  * se =ACK= o =NAK= corrotti
    - ritrasmesso il pacchetto
  * per gestire i duplicati sender aggiunge numero di sequenza
    + 0 o 1
- 2.2
  * stessa funzionalitá ma senza =NAK=
  * =ACK= dell'ultimo pacchetto ricevuto OK invece di =NAK=
- 3.0 - /errors/ and /loss/
  * il canale sottostante puó anche perdere pacchetti
  * implementiamo un'attesa ragionevole
    + dopo di che il mittente se non ha ancora ricevuto =ACK= ritrasmette
    + i ritardi inducono del lavoro in piú con delle sovrapposizioni di invio e risposta
***** Performance
3.0 é corretto, le performance sono problematiche
- il protocollo limita l'uso delle risorse fisiche disponibili
Il protocollo é molto limitato dal $\textsc{rtt}$ in quanto si deve stare in attesa del =ACK= di risposta per poter procedere

**** Pipelining
Per risolvere il problema di performance del =RDT= si continuano a trasmettere pacchetti anche durante l'attesa dell'=ACK=
Ci sono due _forme generiche di pipelined protocols_:
- ~Go-Back-N~
  + sender invia fino a =N= pacchetti _unacked_
    * c'é una finestra di grandezza =N= tra tutti i pacchetti comprendente:
      a) pacchetti inviati, senza =ACK=
      b) pacchetti disponibili ad essere inviati
  + receiver invia solo =ACK= cumulativo
    * non lo invia se c'é un gap
    * non necessita buffering a questo lato
      + si riceve solo nell'ordine corretto, altrimenti si scarta
  + sender ha un timer per il piú vecchio pacchetto unacked
    * quando scade reinvia tutti i pacchetti unacked
- ~Selective Repeat~
  + sender invia fino a =N= pacchetti unacked
  + receiver invia =ACK= singoli
  + sender ha un timer per ciascun pacchetto unacked
    * reinvia solo quello relativo allo scadere

*** Livello di Rete
/Comunicazione logica tra hosts/
**** Datagram
/Internet/
Non c'é setup di chiamata al livello di rete, i router non mantengono stati sulle connessioni.
- non esiste il concetto di connessione a livello di rete
- pacchetti inviati usando l'indirizzo di destinazione

Caratteristiche:
- scambio di dati tra computer
  + servizio elastico, timing variabile
- connessioni diverse tra terminali
  + servizio poco uniforme
- terminali intelligenti
  + semplice nella rete, complesso ai terminali

**** Virtual Circuit
/ATM/
Consiste in:
- path
- =VC= number
  + pacchetti appartenenti a =VC= portano il suo numero invece che l'indirizzo destinazione
- voci delle /forwarding tables/

- signalling protocols
  + setup, mantenimento e teardown =VC=
  + in =ATM=, frame-delay, X.25
  + non usato nell'internet odierno

I router =VC= mantengono informazioni sullo stato della connessione.

Tecnologia evoluta dalla telefonia
- terminali semplici
  + complessitá all'interno della rete
**** Architettura Router
Funzioni principali:
- routing algorithms / protocol
  + /routing processor/
- forwarding datagrams da incoming a outgoing
  + /high-seed switching fabric/
    + switching-rate
      * $N$ multipli del rapporto input/output
    + tipologie
      * memory
        - prima generazione
        - 1 pacchetto alla volta
        - computer classico, switching sotto diretto controllo della =CPU=
      * bus
        - 1 pacchetto alla volta
      * crossbar
        - piú pacchetti per volta
- input
  + line termination
    * /physical layer/
  + link layer protocol
    * /data link layer/
  + lookup, forwarding, queueing
    * datagram dest \rightarrow lookup con forwarding table
    * /queuing/ per sovrapposizione di output, per Head-of-the-Line blocking
- output
  + datagram buffer, queueing
    * /scheduling discipline/ sceglie datagrammi in coda
    * /buffering/ avviene anche con uno switching veloce per via dei pacchetti che vanno allo stesso output
  + link layer protocol
  + line termination
- buffer
  + dimensione approssimata a $\frac{RTT \cdot C}{\sqrt{N}}$
    + $C$ link capacity
    + $N$ numero di flussi

**** Internet Protocol
=IP=
Protocolli:
- routing
- =IP=
  + altri 20B di intestazioni
  + complessivamente 40B di overhead (=TCP= + =IP=) per ogni pacchetto
- =ICMP=
***** IP Fragmentation
Diversi collegamenti all'interno della rete hanno =MTU= diversi
- Max. transfer size
Datagrammi di grandi dimensione frammentati all'interno della rete
- riasseblati alla destinazione
- utilizzati i campi dell'intestazione =IP= per riassemblare i ordine corretto
  + /fragflag/
  + /offset/
    * su 13 bit
      - offset di 8B sul file (moltiplicare per 8 per posizione esatta)
***** Addressing
identificatore a 32-bit per host, interfaccia del router
- un =IP= per interfaccia
  + gestiti dall'=ICANN=
    * Internet Corporation for Assigned Names and Numbers
  + =IP= assegnati dinamicamente nella sottorete con =DHCP=
    * client-server
    * il protocollo permette di utilizzare stessi indirizzi in tempi diversi a host diversi
    * =DHCP= discover broadcast a tutti
      + offer
      + request
      + =ACK=
- Classless InterDomain Routing
  + =CIDR=
  + porzione di sottorete dell'indirizzo
  + formato:
    * =a.b.c.d/x=
      - x # bit nella porzione di sottorete dell'indirizzo
- gli ISP prendono carico degli indirizzi di loro dominio e di tutti i pacchetti a loro indirizzati

***** Network Address Translation
=NAT=
Gli indirizzi, anche se di numero molto grande, non soddisfano la domanda
- in quanto sono assegnati in blocco

Le reti locali utilizzano _un solo IP_ per tutti i dispositivi
- i singoli terminali non sono direttamente raggiungibili
  + livello di sicurezza in piú
- si puó cambiare =ISP= senza cambiare =IP= a tutti i dispositivi in rete locale

Implementazione:
- datagrammi in uscita
  + =IP= sostituito con =NAT=
  + porta originale sostituita con una porta assegnata a quel pacchetto in particolare
  + altri pacchetti della stessa connessione riutilizzano sempre la stessa porta assegnata fino a che necessario
- datagrammi in entrata
  + tradotto attraverso la =NAT= _translation table_

Controverso:
- i router non dovrebbero modificare le intestazione di livelli superiori, livello di rete e di trasporto
  + il =NAT= modifica il livello di trasporto
- viola la comunicazione punto-punto tra host
  + questo crea problemi nel =P2P= ad esempio
    * risolvibile attraverso /relay/

Per rendere raggiungibile direttamente dall'esterno un dispositivo posto dietro =NAT= é possibile:
- associare un indirizzo pubblico ad un indirizzo interno direttamento all'interno del Router
- utilizzare il protocollo =UPnP=
  + Universal Plug and Play
  + automatizza la soluzione statica precedente
- /relay/

***** ICMP
Protocollo di messaggistica
- utilizzato da host e router per comunicare informazioni a livello di rete
- ping

Messaggi =ICMP= costituiti da
- tipo
- codice

Utilizzato da =traceroute=

***** IPv6
128 bit - 16 Byte
Motivazioni principale
- estendere lo spazio degli indirizzi
- migliorare la velocitá di eleborazione dell'intestazione
- non piú /best-effort/ ed /elastica/ ma per facilitare il Quality of Service

Formato:
- lunghezza 40B fissa
- frammentazione non permessa
  + aggiunge messaggi "Packet Too Big"
    * sará il mittente ad adeguarsi alla capacitá trasmissiva del collegamento
- /flow/ label identifica pacchetti della stesso flusso di dati
- non c'é piú il /checksum/
- non ci sono piú le /options/
  + possono essere inserite al di fuori dell'intestazioni

Per la transizioni viene utilzzato il /tunnelling/
- =IPv6= pacchetti trasportati come /payload/ all'interno di pacchetti =IPv4= attraverso router =IPv4=
**** Routing Algorithms
**** Routing
**** Broadcast - Multicast

*** Livello di Collegamento
*** Incapsulamento
Ogni livello che si discende si aggiunge una intestazione
** Sicurezza
Non é stata pensata inizialmente con la sicurezza in mente
- facilitare la comunicazione tra ricercatori
  + con trasparenza

Malware:
- virus
- worm
- spyware
- botnet

Attacchi DoS
- Denial of Service
- attaccanti rendono le risorse sul server non disponibili per il traffico reale con moltissime richieste

Packet Sniffing
- con l'accesso ai mezzi trasmissivi (spesso condivisi)
- intercettazione dei pacchetti trasferiti nel percorso compromesso

IP spoofing
- invio di pacchetti con IP falso, rubato
** Reti Wireless
