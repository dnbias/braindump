:PROPERTIES:
:ID:       f97d251f-6fb4-42da-8878-8fc9d67b2a57
:ROAM_ALIASES: MFI
:END:
#+title: Metodi Formali dell'Informatica
[[id:f956b52b-6fe3-4040-94e5-7474d1813a38][$university]]
Prof: Ugo De' Liguoro
* Info Corso
- Orario:
  + Mer 14-16
  + Ven 11-13
- Testo:
  + [[id:ca905cae-fdf3-421c-a255-ec32435ef818][Programming Language Foundation in Agda]]

* Teoria
** Metodi Formali
Derivano dalla logica-matematica
- Chompsky - Teoria delle Grammatiche
  + paralleli con gli automi
- Linguaggi di programmazione - Linguaggi formali
  + metodo che permette di verificare - Metodi Formale
    - descrizioni formali del comportamento dei programmi

#+begin_quote
In computer science formal methods are a particular kind of mathematically based techniques for the specification, developmetn and verification of software and hardware systems  | Wikipedia
#+end_quote

- Componenti dei metodi formali
  + calcoli logici
  + sistemi di riscrittura
    - semplificazioni
  + linguaggi formali
  + teoria degli automi
  + sistemi di transizione
  + algebra dei dati
  + algebra dei processi
    - esecuzione concorrente
  + algebra relazionale
    - basi di dati
  + semantica dei linguaggi di programmazione
  + teoria dei tipi
  + analisi statica
    - Data Flow
    - Control Flow
    - Abstract Interpretation

L'utilitá é l'analisi matematica che dimostrino la robustezza e la correttezza della progettazione hardware e software

- Tool:
  + Infer
  + Key
  + Viper
*** Il Problema della Verifica
- In:
  + descrizione di un sistema
  + specifica del suo comportamento o sua proprietá
- Out:
  + evidenza del fatto che il sistema soddisfa la specifica
  + controesempio che non funziona

**** Semantica Operazionale
Definisce il significato di un programma come il suo comportamento che, quando termina, tranforma uno stato in un altro
***** Semantica Logica
Pre e Post condizioni che un programma soddisfa
- Floyd
  + metodo delle asserzioni - 1967
    - controllo del flusso di grafi che descrivono le aspettative sullo stato della memoria
- Hoare
  + formalizza le idee di Floyd
  + Logica di Hoare
    - $\{\varphi\} P \{\psi\}$
      + in P out

**** Verifica Statica
Il programma non viene eseguito - statico
Il testing é fatto sull'esecuzione - dinamico
- l'importante é la scelta degli esempi di testing
  + G.J.Myers, /The Art of Software Testing/
- essendo i test infiniti il superamento di qualsiasi test non verifica il programma
  + é un metodo di ricerca degli errori, non di verifica

Processo:
1. Contratto
2. Invariante di Loop
   - esistono euristiche per trovarlo ma non algoritmi
3. Asserzioni Intermedie
   - conducono alla dimostarzione di ció che voglio

**** Logica di Hoare
=HL=
Usiamo logica debole, non dimostriamo la terminazione. Se il programma termina allora é il risultato sará corretto
- Rules:
  + skip
  + assignments
  + sequencing
  + conditionals
  + while loops
  + consequence
***** Correttezza di HL
Teorema: Se la tripla é derivabile in HL, allora é valida
***** Limiti teorici
La logica del primo ordine é corretta e completa ma é _indecidibile_
- Teorema di Church
- non esiste un algoritmo che verifichi che formula logica sia corretta
HL é corretta, ma completa solo in senso debole; include FOL dunque é indecidibile

Allora si utilizzano Truth Assistant, il teorema di Rice ci dimostra che i Verificatori non possono esistere.
- Isabelle
- Coq
- Agda
  + un linguaggio di programmazione funzionale
- VeriFast
  + ProofAssistant dedicato a _Separation Logic_ in C e Java
** Grammatiche
*** Concrete
Descrivo _Grammatiche Senza Contesti_ con le _Regole di Inferenza_

- $\frac{}{n \in Aexp}$
- $\frac{}{x \in Aexp}$
- $\frac{a_1\in Aexp \quad a_2 \in Aexp}{a_1 +  a_2 \in Aexp}$

*** Astratte
**** Backus Normal Form
Utiliziamo la notazione _carrificata_
#+begin_example
vname ::== String
aexp ::== N n | V x | Plus aexp aexp | Times aexp aexp
#+end_example
**** Agda
=Set=, insieme o =Tipo=
#+begin_example
data aexp: Set nohere
N: N -> aexp
V: String -> aexp
Plus: aexp -> aexp -> aexp

depth: aexp -> N
  depth (Nn) = 0
  depth (Vx) = 0
  depth (Plus a b) = 1 + max (depth a) (depth b)
#+end_example

Dim. per induzione strutturale:
#+begin_example
depth (Plus a b) <= size (Plus a b)
#+end_example
