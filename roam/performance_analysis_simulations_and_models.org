:PROPERTIES:
:ID:       664d99ea-5c74-47c4-89f6-4bbee86e5bca
:END:
#+title: Performance Analysis - Simulations and Models
#+date: [2022-09-22 Thu 00:00]
#+filetags: university simulation
Taught by Gianfranco Balbo, Gaeta
- Lawrence M. Leemis, Stephen K. Park, /Discrete Event Simulation: a first course/, Pearson - Prentice Hall
- Denning, Buzen, /[[id:70af4f43-65f9-474c-9ffb-fa627cd96b47][The Operational Analysis of Queueing Network Models]]/, ACM Computing Surveys, 1978
* Systems
This course focuses on systems that are:
- stochastic
- dynamic
- discrete-event

* Introduction
** Discrete-event simulation
- purpuse, modeling - simulating - analyzing systems
- way, computation and mathematical techniques
- experiments on the model

A *model* is a conceptual framework describing a system
The simulations are going to use *Montecarlo*-based techniques[fn:montecarlo]

Model Development (typically done iteratively):
1. Goals and objectives
2. Build a /conceptual model/
3. Convert into a /specification model/
4. Convert into a /computational model/
5. Verify
6. Validate

** Formalisms
- *Queueing Networks*
  - concurrency
  - congestion
- *Stochastic Petri Nets*
  - concurrency
  - congestion
  - sychronization

Queues can use different /disciplines/ or algorithms to regulate the job handled by the server
- =FIFO=
- =LIFO=
- =SIRO=, serve in random order
- using some kind of priority, usually =SJF=

Basic assumptions on queues:
- =FIFO=
- /non-preemptive/
  - once initiated, service will continue until completion
- /conservative/
  - /server/ stays idle if there is one or more jobs in the service node

For a job $i$
- arrival time $a_{i]$
- delay $d_{i]$
- service begins at time $b_{i] = a_{i] + d_{i]$
- service time $s_{i}$
- wait time $w_{i} = d_{i} + s_{i]$
- departure time $c_{i] = a_{i} + w_{i}$
- interarrival time $\tau_{i} = a_{i} - a_{i-1}$
- idle time $e_{i} = a_{i} - c_{j-1}$
  - $0$ if job arrives whle the server is busy

In general:
\[B = \sum_{i=1}^{n} s_{i}\]
\[E = \sum_{i=1}^{n} e_{i}\]

Observing these informations we can distinguish:
- *job-averaged statistics*
  - average interarrival time
\[\overline \tau = \frac{1}{n}\sum^{n}_{i=1}\tau_{i}=\frac{a_{n}}{n}\]
  - input rate $\theta = \frac{1}{\overline \tau}$
  - average service time
\[\overline s = \frac{1}{n}\sum^{n}_{i=1} s_{i}=\frac{B}{n}\]
  - service rate $\mu = \frac{1}{\overline s}$
    - maximum throughput, in the case that the server was never idle
  - total simulation time $T = c_{n} - c_{0}$
  - throughput \[X = \frac{n}{T}\]
  - utilization \[U = \frac{B}{T}\]


- *time-averaged statistics* are defined by the area under a curve (integration)
  - defined 3 functions
    - $n(t)$, number of jobs in the service node at time $t$
    - $q(t)$, number of jobs in the queue at time $t$
    - $y(t)$, number of jobs in service at time $t$
    - $n(t) = q(t) + y(t)$
  - $$\overline n = \frac{1}{T} \int_{0}^{T} n(t) dt$$
  - $$\overline q = \frac{1}{T} \int_{0}^{T} q(t) dt$$
  - $$\overline y = \frac{1}{T} \int_{0}^{T} y(t) dt$$
    - also the /server utilization/ (probability, in the limit)
    - $$\overline y = \frac{\sum_{i=1}^{n} s_{j}}{c_{n}} = \frac{B}{c_{n}} = \frac{c_{}_{n}- E}{c_{n}}$$
  - /traffic intensity/, input rate to service rate ratio
    - $$\rho = \frac{1/\overline \tau}{1/\overline s} = \frac{c_{n}B}{a_{n} c_{n}} = \bigg (\frac{c_{n}}{a_{n}}\bigg )\overline y$$

#+begin_quote
A *Trace File* is a log of all the arrival and service times.
#+end_quote



[fn:montecarlo] Computational algorithms using repeated random sampling to obtain results

* Discrete-Event Simulation
The general structure of the simulator is made of different /handlers/:

#+begin_code c
void initialize() {
    clock = 0;
    halt = false;
    nsys = 0;
    Busy = 0;
    Area_n = 0;

    arrival_t = GetArrival(fp);
    service_t = GetService(fp);

    event_notice = get_new_node();
    event_notice->event.type = ARRIVAL;
    event_notice->event.occur_time = arrival_t;
    event_notice->event.service_time = service_t;
    schedule(event_notice); // scheduling the first event

    event_notice = get_new_node();
    event_notice->event.type = END;
    event_notice->event.occur_time = End_time;
    schedule(event_notice);
}
#+end_code

In the engine we call the *handlers*, these are best kept as small and fast as possible.
It is better to create different variants of the events with simple handles than have fewer but more complex handlers.
#+begin_code c
void engine(void) {
    int event_type;
    double oldclock, delta;
    nodePointer new_event;

    new_event = event_pop();

    oldclock = clock;
    clock = new_event->event.occur_time;
    delta = clock - oldclock;

    // nsys > 0, somebody was in the queue
    if (nsys > 0) {
        Busy = Busy + delta;
        Area_n = Area_n + nsys * delta;
    }

    // transition
    event_type = new_event->event.type;
    switch(event_type) {
        case ARRIVAL : arrival(new_event);
            break;
        case DEPARTURE : departure(new_event);
            break;
        case END : end(new_event);
    }
}
#+end_code

#+begin_code c
void arrival(struct node* node_event) {
    struct node* next_job;

    nsys++;
    if (nsys == 1) { // Nobody was in queue
        node_event->event.type = DEPARTURE;
        node_event->event.occur_time = clock + node_event->event.service_time;
        schedule(node_event);
        // the engine popped the event

        //  arrival puts it back as a departure
    } else {
        enqueue(node_event);
    }
    arrival_t = GetArrival(fp);
    service_t = GetService(fp);

    next_job = get_new_node();
    next_job->event.type = ARRIVAL;
    next_job->event.occur_time = arrival_t;
    next_job->event.service_time = service_t;
    schedule(next_job);
}
#+end_code

#+begin_code c
void departure(struct node* node_event) {
    double waiting_time;
    struct node* next_job;

    nsys--;
    if (nsys > 0) {
        next_job = dequeue();
        next_job->event.type = DEPARTURE;
        next_job->event.occur_time = clock + next_job->event.service_time;
        schedule(next_job);
    }
    return_node(node_event);
}
#+end_code

#+begin_code c
void End(struct node* node_event) {
    halt = true;
    return_node(node_event);
}
#+end_code

** Memory Management
To have an efficient memory management it is important not to use =GC=, instead it's better to reuse as many chunks of memory as possible. That is because the memory manager operation are very time-intensive.
This can be done by having an =available-list= of chunks where we can take and place back chunks, interrogating the memory manager as little as possible.

* Tandem Network
A network made of two queues each with its output connected to the others input.
The =Event Notice= follows the life of a single job, in this structure the clients/jobs are continuously passing from one queue to another. This means there is no need for an =Available Queue= anymore as the number of notices is not gonna change during the simulation.
The basic assumption of the *clock* is that it is always cabable of the time granularity needed to distinguish between events that occur "at the same time".
- so, while events pass from one queue to another in 0 time, the clock is able to distinguish and establish which event (departure from one | arrivale to the other) is happening first
* Operational Analysis
See [[id:4dda14f3-6d01-4265-a25a-e85ce6696fe0][Denning78/Notes]].
