:PROPERTIES:
:ID:       8c1765a3-7f08-4312-b5d0-8653b62dbcdf
:END:
#+title: VeriFast
#+date: [2022-05-03 Tue 03:23]
#+filetags: tool compsci
- [[https://github.com/verifast/verifast][Github Page of the project]]
- [[id:217b3f95-7f36-4be7-8644-3c0d8afcef57][VeriFast: Imperative Programs as Proofs]]
- [[id:fa50b908-37bf-4fc7-bf13-dd1c84ab8775][Verification of Imperative Programs: The VeriFast Approach]]

A tool for modular formal verification (/static symbolic analysis/) of [[id:87d3d62a-10a4-45af-ae97-c949be124080][Correctness]] properties of single-threaded and multithreaded C and Java Programs, annotated with preconditions and postconditions written in [[id:fa8dfe1a-7b8c-46a8-b37e-52e4335073f3][Separation Logic]].

* Theoretical Syntax
- $\exists$ and $\forall$ can be defined as recursive ~predicates~
- a basic imperative language
- the language has pointers

* Symbolic State
$(s,h,\pi)$
- store
- symbolic heap
- pattern conditions

* Production - Consumption
1. production of $a$
   * instantiation of chunk
   * we have an assumption
2. consumption of $a$
   * removal of chunk
   * we prove the assumption

\[\text{produce}(h,s,\pi,a,Q) =
\begin{cases}
\pi,s,h' \vdash_{\text{SMT}} a \text{ with }h\perp h'\\
Q (s, h \uplus h', \pi') \text{ with }\pi \subseteq \pi'
\end{cases}\]

\[\text{consume}(h,s,\pi,a,Q) =
\begin{cases}
\pi,s,h' \vdash_{\text{SMT}} a \text{ with }h = h' \uplus h''\\
Q (s, h'', \pi') \text{ with }\pi \subseteq \pi'
\end{cases}\]

Then these are used by 2 routines:
- ~verify(h,s,$\pi$,f(e),Q) where $f(x)$ requires $A_{1}$; ensures $A_{2}$;~
- ~valid($f(x)$ requires $A_{1}$; ensures $A_{2}$; $\{\overline{s}\}$)~

* Branches
Happens in 2 cases:
a. there is an ~if~ statement
b. there is an ~heap~ allocation
   - there is the case where the allocation does not succeed

* Examples
No preconditions are ~true~, empty heap is ~emp~
#+begin_src C
struct account
{
    int balance;
};

struct account *create_account()
/*@ requires true;
     ensures malloc_block_account(result) &*&
              result->balance |-> 0;
@*/
{
    struct account *myAccount = malloc(sizeof(struct account));
    if (myAccount == 0) abort();
    myAccount->balance = 0;
    return myAccount;
}

void account_set_balance(struct account *myAccount, int newBalance)
//@ requires myAccount->balance |-> _;
//@ ensures  myAccount->balance |-> newBalance;
{
    myAccount->balance = newBalance;
}

void account_deposit(struct account *myAccount, int amount)
//@ requires myAccount->balance |-> ?balance;
//@ ensures  myAccount->balance |-> (balance + amount);
{
    myAccount->balance += amount;
}
#+end_src

Here we use a ghost variable ~value~ using /pattern matching/
#+begin_src C
int account_get_balance(struct account *myAccount)
//@ requires myAccount->balance |-> ?value;
//@ ensures result == value &*&
//@         myAccount->balance |-> value;
{
    return myAccount->balance;
}

void account_dispose(struct account *myAccount)
//@ requires malloc_block_account(myAccount) &*&
//@          myAccount->balance |-> _;
//@ ensures  emp;
{
    free(myAccount);
}
#+end_src

~predicates~ are abbreviations
#+begin_src C
/*@
predicate account_pred(struct account *myAccount, int theLimit, int theBalance) =
    myAccount->limit |-> theLimit &*& myAccount->balance |-> theBalance &*&
    malloc_block_account(myAccount);
@*/

int account_get_balance(struct account *myAccount)
//@ requires account_pred(myAccount, ?limit, ?balance);
//@ ensures  account_pred(myAccount, limit, balance) &*& result == balance;
{
   //@ open account_pred(myAccount, limit, balance);
    return myAccount->balance;
    //@ close account_pred(myAccount, limit, balance);
}
#+end_src
