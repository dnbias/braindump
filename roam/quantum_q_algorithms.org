:PROPERTIES:
:ID:       07f2115c-edc3-4541-812b-19534cf6e019
:END:
#+title: Quantum e Algoritmi in Q#
#+date: [2022-05-12 Thu 19:31]
#+filetags: university thesis compsci
- Tags: [[id:6e504ff7-9a50-4a47-901d-4c524c229bc6][Quantum Computing]], [[id:b9d02edb-6458-4237-88de-41fb865974d2][CalcCompl]], [[id:d7686f15-7f24-476e-9ecf-87ef577d5a4c][Deutsch-Jozsa Algorithm]]
- Source: [[id:c2bda57f-a02a-460c-96a2-796dd2fee708][Learn Quantum Computing with Python and Q#]]

* Ambiente
L'ambiente di esecuzione ~Q#~ puó essere configurato sul editor =Visual Studio Code= tramite l'add-on proprietario di Microsoft.

Oppure é possibile sviluppare codice ~Q#~ ed eseguirlo tramite =Jupyter Notebook= tramite ~Python~.
* Algoritmo di Deutsch-Jozsa
L'algoritmo di Deutsch-Jozsa ha interesse storico in quanto primo algoritmo quantico in grado di superare in performance il miglior algoritmo classico corrispondente, mostrando che possono esistere vantaggi nel calcolo quantico. Spingendo la ricerca in questa direzione per determinati problemi.

L'algoritmo tratta la decisione di una funzione $f$ booleana con $n$ bit in input
\[f(\{x_{0},x_{1},\cdots,x_{n}\}) \rightarrow 0\text{ o }1\]

Questa funzione su cui agisce l'algoritmo ha la proprietá di essere una di due forme:
- costante
- bilanciata

E quindi restituisca per tutti gli input $\{x_{0},x_{1},\cdots,x_{n}\}_{}$ lo stesso risultato se costante oppure restituisca /esattamente/ $0$ per metá degli input e $1$ per metá degli input.

** La Soluzione Classica
Nella soluzione classica nel *caso migliore* due /query/ all'oracolo sono sufficienti per riconoscere la funzione $f$ come bilanciata.
Per esempio si hanno due chiamate:
\[f(0,0,\cdots) \rightarrow 0\]
\[f(1,0,\cdots) \rightarrow 1\]

Dato che é assunto che $f$ é /garantita/ essere costante oppure bilanciata questi risultati ci dimostrano $f$ come bilanciata.

Per quanto riguarda il caso peggiore tutte le nostre interrogazioni daranno lo stesso output, decidere in modo certo che $f$ sia costante necessita di metá piú uno interrogazioni.
In quanto il numero di input possibili é $2^{n}$ questo significa che saranno necessarie $2^{n-1}+1$ interrogazioni per essere certi che $f(x)$ sia costante nel caso peggiore.

** La Soluzione Quantica
Tramite la computazione quantica é possibile risolvere questo problema con un'unica chiamata della funzione $f(x)$.
Questo a patto che la funzione $f$ sia implementata come un oracolo quantico, che mappi:
$|x\rangle | y \rangle$ a $| x \rangle |y \oplus f(x) \rangle$ [fn:oplus]


I passi dell'algoritmo in particolare sono:
1. prepara 2 registri di =qubit=, il primo di $n$ =qubit= inizializzato a $| 0 \rangle$ e il secondo di un singolo =qubit= inizializzato a $| 1\rangle$
2. applica ~Hadamard~ a entrambi i registri
3. applica l'oracolo quantico
4. a questo punto il secondo registro puó essere ignorato, riapplica ~Hadamard~ al primo registro
5. misura il primo registro, questa risulta $1$ per $f(x)$ costante e $0$ altrimenti nel caso bilanciato

#+caption: i passi dell'algoritmo in forma di circuito
[[../media/img/deutsch_steps.png]]

*** single-bit Deutsch-Jozsa
*** n-bit Deutsch-Jozsa

[fn:oplus] dove $\oplus$ é l'addizione modulo $2$
