+++
title = "Reti I"
author = ["Daniel Biasiotto"]
tags = ["university"]
draft = false
+++

## Info Corso {#info-corso}

-   Prof:
    -   Marco Botta
-   Orari:
    -   Mar 16-18
    -   Mer 16-18
    -   Gio 11-13 (in alternativa a [ProgIII]({{< relref "20210921090752-programmazione_iii.md" >}}))
-   Testo:
    -   [Computer Netwoking - A Top-Down Approach]({{< relref "20210921114932-computer_netwoking_a_top_down_approach.md" >}})


## Teoria {#teoria}


### Introduzione alle Reti di Calcolatori {#introduzione-alle-reti-di-calcolatori}

_Internet come esempio delle reti_


#### Componenti {#componenti}

-   Computing Devices connessi
    -   hosts / sistemi terminali
        -   alla periferia della rete
        -   eseguono degli applicativi
            -   applicazioni di rete
    -   links
        -   wireless
        -   wired
    -   router
        -   collegati tra di loro
        -   collegati agli hosts
            -   permettono a questi di comunicare a grandi distanze
            -   <span class="underline">packet switching</span>
-   Gerarchia
    -   Internet come rete di reti
    -   home Network
        -   Regional ISP
            -   Global ISP
                -   mobile Network
        -   Institutional Network

In sostanza:

-   hosts: clients, servers / dispositivi periferici alla rete / <span class="underline">edge networks</span>
    -   in prevalenza wireless
    -   <span class="underline">access network</span> punto di accesso
        -   per connettere terminali si utilizzano _router di frontiera_
        -   reti di accesso residenziale/istituzionale/mobile
-   routers in profonditá nella rete / <span class="underline">core network</span>
    -   in prevalenza wired


##### Accesso {#accesso}


###### Digital Subscriber Line {#digital-subscriber-line}

`DSL`
Utilizza linee telefoniche esistenti

-   splitter
    -   dati vanno su Internet
    -   voce va sulla rete telefonica

La linea é asincrona:

-   Up &lt; 1Mbps
-   Down &lt; 10Mbps
    -   poiché questa é la piú utilizzata generalmente

Collegato direttamente alla Centrale


###### Cable Network {#cable-network}

Via cavo, utilizzata dagli anglosassoni

-   cavo condiviso da vari utenti
-   cable modem
    -   collegato da uno splitter
        -   dati vanno su Internet
        -   segnale televisivo va su TV
        -   vengono utilizzate tecniche di multiplexing
-   Hybrid fiber coax
    -   Up &lt; 2Mbps
    -   Down &lt; 30Mbps

A differenza della DSL non ha un collegamento diretto al centtrale


###### Enterprise Access Network {#enterprise-access-network}

Ethernet, sono dei Router che fanno parte della rete internet del ISP

-   institutional router
    -   Ethernet switch
        -   connessioni singole
-   Velocitá: 10Mbps, 100Mbps, 1Gbps, 10Gbps


###### Wireless Access Network {#wireless-access-network}

-   LAN:
    -   100ft
    -   802.11 b/g: 11Mbps, 54Mbps
-   Wide-Area
    -   telco operator, 10km
    -   1 - 10 Mbps
        -   3G, 4G, LTE


##### Host {#host}

Invio di pacchetti di dati tra gli Host
pacchetti di bit di lunghezza \\(L\\), trasmissione a velocitá \\(R\\)

-   packets
-   link bandwidth

Packet Transmission Delay = \\(\frac{L}{R}\\)


##### Mezzi Trasmissivi {#mezzi-trasmissivi}

-   guiditati
    -   il segnale segue un percorso ben preciso
    -   cavi
        -   Twisted Pair (TP)
            -   2 cavi di rame intrecciati
        -   Coaxial Cable
            -   2 cavi di came concentrici
            -   maglia di rame intorno per schermare
            -   cavo interno biderezionale banda langa
        -   Fiber Optic
            -   fibre di vetro all'interno della quale passa la luce
            -   il segnale é luminoso, ogni bit é un impulso luminoso
            -   molto flessibili
            -   molto veloci, immune alle interferenze elettromagnetiche
                -   tasso di errore molto basso
-   non guidati
    -   onde radio
        -   segnali trasportati nello spettro elettromagnetico
        -   possono essere riflessi, ostruiti, interferiti
        -   Microonde terresti
            -   &lt; 45Mbps
        -   LAN WiFI
            -   &lt; 11 - 54Mbps
        -   Wide-Area
            -   3G, 4G
        -   satellitare
            -   delay per la distanza con il satellite
            -   da Kbps a Mbps


##### Nucleo della Rete {#nucleo-della-rete}

Packet Switching preferito perché permette a piú utenti di usare la rete contemporaneamente

-   questo in quanto é bassa la probabilitá che tutti gli utenti siano attivi contemporaneamente


##### Packet Switching {#packet-switching}

Router Interconnessi che comunicano usando il packet switching

-   ogni pacchetto ha lo stesso formato e dimensione, semplici da <span class="underline">smistare</span> verso la destinazione
-   ogni pacchetto usa l'intera capacitá del collegamento per essere inviato

<span class="underline">Store-And-Forward</span>

-   il router deve ricevere almeno parte del pacchetto, supponiamo tutto
-   solo allora puó decidere su quale collegamento in uscita trasmetterlo

<span class="underline">Queuieng and Loss</span>

-   in uscita solo un pacchetto puó passare per volta
    -   si formano delle code nel `buffer` del router
    -   se la coda é piena un nuovo pacchetto viene scartato

-   Funzioni principali del Nucleo
    -   routing - instradamento
        -   Routing Algorithm
            -   determina il cammino che i pacchetti dovranno seguire
        -   Local Forwarding Table
    -   forwarding - inoltro
        -   copia sull'uscita scelta il pacchetto

Piú semplice del circuit switching, i router non devono attivarsi per creare la connessione, ma condividendo le risorse possono crearsi congestioni

-   puó essere garantita banda ad alcune app audio/video per ottenere del comportamento simile al circuit switching


###### Circuit Switching {#circuit-switching}

Creare un collegamento diretto tra mittente e destinatario
C'é una ridondanza di collegamenti tra i router

-   a seguito di una richiesta i router aprono e chiudono i circuiti per creare una linea diretta di circuiti
-   con questo schema non ci sono risorse condivise a differenza del Packet Switching
    -   i pacchetti andranno alla massima velocitá possile
    -   un circuito non utilizzato puó essere considerato uno spreco

<!--list-separator-->

-  FDM

<!--list-separator-->

-  TDM


#### Protocolli {#protocolli}

Skype, TCP, IP, HTTP, 802.11
Definiscono:

-   formato,ordine di messaggi ricevuti e mandati
-   azioni intraprese su invio e ricevuta di messaggi


#### Internet Stardards {#internet-stardards}

-   RFC: Request for comments
-   IETF: Internet Engineering Task Force
    -   ente che valuta e accetta standard di comunicazione


#### Packet Delay {#packet-delay}

\\(d\_{nodal} = d\_{proc} + d\_{queue} + d\_{trans} + d\_{prop}\\)

-   processing
-   queue
    -   dipende dalla congestione
-   transmission
    -   dipende dalla velocitá
    -   \\(L/R\\)
-   propagation
    -   \\(d/s\\)
    -   \\(d\\): lunghezza del collegamento
    -   \\(s\\): velocitá di propagazione nel medium
        -   \\(2e8\\) m/sec

Se il buffer é pieno il packetto é perso (_packet drop_)
\\(\frac{L\cdot a}{R}\\) = traffic intensity
\\(a\\) é la quantitá media di pacchetti in entrata
quando questa frazione supera 1 i bit in entrata superano la capacitá trasmissiva, i buffer si vanno a riempire


##### Packet Loss {#packet-loss}

Il buffer (coda) é piena, un pacchetto é perso, viene comunicato al router precedente/alla sorgente/viene ignorato


#### Throughput {#throughput}

due casi:

1.  \\(R\_{S}<R\_{C}\\)
2.  \\(R\_{S}>R\_{C}\\)

Throughput, la quantitá minima

-   compreso il _bottlenoek link_


#### Servizi {#servizi}

Internet puó essere definito come infrastruttura di servizio ad applicativi

-   che ne hanno bisogno per comunicare tra loro

Internet puó anche fornire un'interfaccia di programmazione utile alla comunicazione

-   Generalmente:
    -   server
        -   fornisce un servizio
    -   client
        -   accede a servizi

Ma la divisione non é netta, ogni Computer puó essere entrambi

L'ISP fornisce una certa bandwidth

-   che dipende anche dal proprio PC, che potrebbe fare bottleneck


#### Storia {#storia}

-   1961: Kleinrock
    -   queuing theory dimostra l'efficacia del packet-switching
-   1964: Baran
    -   packet-switching in reti militari
-   1967: ARPAnet
    -   dell'Advanced Research Project Agency
-   1969
    -   attivazione primo nodo ARPAnet
-   1972
    -   prima vera rete ARPAnet, posta elettronica
-   1970: ALOHAnet
-   1974: Cerf and Kahn
    -   architettura di interconnessione delle reti
    -   principi alla base dell'architettura odierna
        -   minimalismo
        -   autonomia
        -   controllo decentralizzato
        -   best effort service model
        -   dispositivi stateless
-   1976: Xorox
    -   Ethernet
-   1979: ARPAnet ha 200 nodi

Proliferano Reti e Protocolli:

-   1983: TCP/IP
-   1982: smtp e-mail
-   1983: DNS
-   1985: ftp
-   1988: controllo congestioni TCP

Commercializzazione e World Wide Web

-   1990~: ARPAnet decommisionata
-   1990~: Web
    -   Berners-Lee
        -   HTTP, HTML
-   1994: Mosaic, poi Netscape


### Livelli {#livelli}


#### Livello Applicativo {#livello-applicativo}

Applicazioni su terminali, permettono uno sviluppo e propagaziose software molto veloce

-   il software non si occupa dei dettagli implementativi della comunicazione web


##### Concetti delle Implementazioni {#concetti-delle-implementazioni}

Esistono strutture diverse per le applicazioni

-   client-server
    -   server - attende richieste
        -   host sempre acceso
        -   IP permanente
        -   data centers
    -   client - invia richieste
        -   comunicano con il server
        -   puó essere connesso periodicamente
        -   puó avere IP dinamico
        -   non comunicano direttamente tra loro
-   peer-to-peer
    -   non esiste un server sempre attivo
    -   i peer possono comunicare direttamente
    -   i peer richiedono servizio ad altri peer che li fornincono
    -   auto-scalabile

I processi inviano/ricevono messaggi attraverso i `socket`

-   analogo ad una porta
-   il percoso e il trasporto é lasciato ai livelli sottostanti

Per ricevere i messaggi i processi devono avere un <span class="underline">identificatore</span>

-   l'host ha un IP unico, ma non basta
    -   possono esserci tanti processi in esecuzione
-   IP-host + port number
    -   HTTP server: 80
    -   mail servel: 25


##### Protocolli di Livello Applicativo {#protocolli-di-livello-applicativo}

Definiscono

-   tipo dei messaggi
-   sintassi dei messaggi
-   semantica dei messaggi
-   regole per quando si inviano messaggi e si risponde

Due tipologia

-   open protocols
    -   RFC liberamente consultabili
    -   permettono interoperabilitá
-   proprietary protocols


###### Integritá dati {#integritá-dati}

Alcune applicazioni non necessitano dati al 100% corretti
Altre necessitano della completa integritá dei dati


###### Tempi di comunicazione {#tempi-di-comunicazione}

Alcune applicazioni necessitano una certa temporizzazione, delay basso


###### Throughput {#throughput}

Alcune applicazioni necessitano un minimo throughput da mantenere per funzionare

-   multimedia
-   a differenza di file-transfer
    -   elastic app


###### Sicurezza {#sicurezza}

Criptazione dei dati, integritá dei dati


###### TCP {#tcp}

-   reliable transport
-   flow control
-   congestion control
-   no
    -   timing
    -   security
    -   minimum throughput
-   connection-oriented


###### UDP {#udp}

-   unreliable data transfer
-   no
    -   reliability
    -   flow control
    -   timing
    -   security

Non fornisce servizi particolari, é utilizzato per esempio da applicazioni multimediali

-   permette di inviare dati alla stesso velocitá a cui il mittente li puó inviare


###### HTTP {#http}

`HyperText Transfer Protocol`

-   pagine = insieme di oggetti
-   pagine che hanno riferimenti ad altri oggetti
    -   identificati URL

-   client: browser
-   server: web server

Utilizzando TCP

-   lato client inizializza connessione creando socket su client e connettendosi alla porta 80 sul server

HTTP é _stateless_

-   non mantiene informazioni riguardo le passate connessioni
-   questo perché un protocollo con stato é molto complesso

-   _non-persistent_
    -   al massimo 1 oggetto viene inviato su TCP
        -   poi si chiude
    -   si deve aprire una nuova connessione per ogni UL/DL
    -   `RTT` tempo di andata e ritorno per dati dal client al server
        -   puó essere calcolato dal client con questa definizione

-   _persistent_
    -   viene mantenuta la stessa connessione TCP per un periodo
    -   puó velocizzare leggermente la comunicazione
    -   1.0

-   Metodi
    -   POST
        -   web page include input
    -   URL

-   differenze versioni
    -   1.0
        -   GET
        -   POST
        -   HEAD
    -   1.1
        -   precedenti
        -   PUT
        -   DELETE

<!--list-separator-->

-  Status Codes

    -   200 OK
    -   301 Moved Permanently
    -   400 Bad Request
    -   404 Not Found
    -   505 HTTP Version Not Supported

<!--list-separator-->

-  Cookies

    Dato che il protocollo é _stateless_ i cookies sono utilizzati per memorizzare alcune informazioni

    -   4 componti
        -   header HTTP response
        -   header HTTP request
        -   cookies mantenuti sulla memoria del browser
        -   DB backend sito Web

    Utilizzati per

    -   mantenere autorizzazioni
    -   carrelli della spesa
    -   pubblicitá targettizzata
    -   sessione Web utente (email)

<!--list-separator-->

-  Web Caches

    Per fornire all'utente ció che richiede senza interagire direttamente con il server d'origine

    -   una richiesta giá fornita puó essere risolta da un _proxy server cache_
        -   solitamente installati dalle ISP
        -   riduce il carico sul link di accesso
            -   secondo un suo _hit rate_
    -   lo stesso browser inserisce gli oggetti ricevuti in cache

<!--list-separator-->

-  Conditional GET

    Per controllare che gli oggetti ricevuti siano aggiornati

    -   le cache fanno C.GET al server
        -   la risposta non contiene nessun oggetto se la versione in cache sia aggiornata


###### FTP {#ftp}

`File Transfer Protocol`

-   TCP, per trasferimento affidabile
-   client-server
-   porta 20-21
-   Richiede autenticazione
    -   primo TCP - client puó navigare il filesystem remoto
        -   chiusa alla fine della comunicazione
    -   secondo TCP - dopo file transfer command il server apre connessione (porta 20)
        -   chiusa alla fine della trasmissione del file
-   control connection: _out of band_
    -   2 canali diversi
-   il server FTP mantiene lo stato
    -   directory corrente
    -   autenticazione utente

<!--list-separator-->

-  Comandi e Codici

    Comandi

    -   USER username
    -   PASS password
    -   RETR filename
    -   STOR filename
    -   CD directory

    Codici di ritorno

    -   331 Username OK, password required
    -   125 data connection already open
    -   425 Can't open data connection
    -   452 Error writing file


###### SMTP {#smtp}

`Simple Mail Transfer Protocol`
3 componenti

-   user agents
    -   client
    -   interfaccia utente
-   mail servers
    -   i messaggi in uscita e in entrata vengono memorizzati qui
-   SMTP
    -   utilizzato nella comunicazione diretta tra i mail server, o dai user agents ai server

Specifiche:

-   porta 25
-   trasferimento diretto dei messaggi <span class="underline">tra i server</span>
-   3 fasi
    -   handshake
    -   transfer
    -   closure
-   comandi/risposte
    -   ASCII
    -   Status code &amp; frase descrittiva
-   messaggi in ASCII 7-bit
-   connessioni <span class="underline">persistenti</span>
-   protocollo di tipo _push_
    -   invia dati al server, al contrario di `HTTP`
-   oggetti multipli fanno <span class="underline">parte dello stesso messaggio</span>
    -   mentre `HTTP` incapsula ogni oggetto all'interno di una risposta ognuno


###### POP3 {#pop3}

-   authorization phase
    -   user, pass
    -   OK, ERR
-   transaction phase
    -   list, retr, dele, quit


###### DNS {#dns}

`Domain Name System`
_protocollo di Livello Applicativo_

-   Internet hosts router
    -   IP address 32 bit
    -   nome simbolico leggibile
-   `DNS` si occupa di mappare IP a nome e viceversa

<!--list-separator-->

-  Specifiche

    -   database <span class="underline">distribuito</span>
    -   host e name server comunicano per risolvere i nomi in IP
    -   é implementato come <span class="underline">Application-Layer</span>
        -   la complessitá é lasciata ai sistemi terminali
            -   se fosse centralizzato sarebbe l'unico punto di fallimento, database singolo e lontano, grande traffico, manutenzione complessa e costosa
    -   <span class="underline">distribuisce il carico</span>
        -   indirizza il client che fa la richiesta verso l'indirizzo IP meno carico di richieste tra quelli disponibili

    Il sistema é distribuito e gerarchico

    -   com _DNS servers_
        -   yahoo.com _DNS serves_
        -   ...
    -   org _DNS servers_
        -   pbs.org _DNS servers_
    -   edu _DNS servers_
        -   poly.edu _DNS servers_

<!--list-separator-->

-  Gerarchia

    <!--list-separator-->

    -  Root

        I server DNS radici sono 13, in tutto il mondo

        -   interrogati solo se uno dei server sottostanti non riesce a risolvere il nome

    <!--list-separator-->

    -  TLD

        `Top Level Domain`
        com, org, net, edu, jobs, uk, it, fr
        Educause e Network Solution gestiscono questi domini

    <!--list-separator-->

    -  Authorative DNS

        `DNS` propri delle organizzazioni pubbliche e private

    <!--list-separator-->

    -  Local DNS

        Non appartengono strettamente alla gerarchia

        -   ogni ISP ne ha uno
        -   quando l'host fa una query questa é inviata a questo `DNS`
            -   gestito localmente
            -   se non puó risolvere l'indirizzo agisce come proxy e risale la gerarchia
                -   la query puó essere _ricorsiva_ o _itecativa_

<!--list-separator-->

-  Caching

    Una volta risolto un indirizzo il servel lo memorizza

    -   timeout, per evitare associazioni obsolete - `TTL`
        -   _time to leave_
    -   tipicamente la cache é mantenuta nei DNS locali

<!--list-separator-->

-  Resource Records

    `RR`
    `(name, value, type, ttl)`

    -   tipi
        -   `A`
            -   name = hostname
            -   vasue = IP
        -   `CNAME`
            -   name = sinonimo
            -   value = hostname / nome canonico
        -   `NS`
            -   name = domain
            -   value = hostname del Authorative DNS
        -   `MX`
            -   name = nome
            -   value = mailserver

<!--list-separator-->

-  Messaggi

    -   header
        -   identification
        -   flags
            -   query or reply
            -   recursive or not
            -   recursion available
            -   reply authoritative
    -   questions
        -   name, type
    -   answers
        -   RRs
    -   authority
    -   info


##### Architetture {#architetture}


###### Client-Server {#client-server}


###### P2P {#p2p}

`Peer to Peer`
Non esiste un server sempre attivo

Utilizzato in

-   condivisione di file
    -   BitTorrent
        -   file diviso in _chunks_ dal server e distribuiti in rete
        -   i peer condividono tra loro (torrent)
        -   **tracker**
            -   tiene traccia dei _chunks_ dei peer
            -   registra i peer
        -   **tit-for-tat**
            -   ci si scambia _chunks_ dai peer piú vicini, piú a contatto
            -   ogni 30 secondi si selezionano peer random
-   VoIP
-   streaming

Qualunque Peer é un pari, ognuno di essi puó condividere risorse

<!--list-separator-->

-  Skype

    Inerentemente `P2P`
    Server:

    -   gestisce login
    -   mette in contatto i peer

    Clients

    -   mappati sui SuperNodi
        -   username `->` IP

    Peer riflettori - _relays_

    -   I `NAT` non permettono connessione diretta tra i clients
    -   i supernodi fanno da _relay_
        -   i supernodi tra loro comunicano
        -   aprono una connessione tra i dispositivi


##### Programmazione Socket {#programmazione-socket}

-   Socket - operato dallo sviluppatore
    -   porta tra processo e protocollo di trasporto end-to-end
-   TCP - operato dal `OS`
    -   buffer
    -   variabili
-   UDP
    -   non c'é connessione tra client e server
        -   questi si scambiano solo messaggi
    -   i dati possono perdersi o essere consegnati in ordine diverso a quello di invio


#### Livello di Trasporto {#livello-di-trasporto}

_Comunicazione logica tra processi_

-   affidabile, consegna ordinata
    -   **TCP**
-   non affidabile, consegna disordinata
    -   **UDP**


##### Multiplexing {#multiplexing}

-   Multiplexing mittente
    -   aggiunge <span class="underline">transport header</span>
-   Demultiplexing ricevente
    -   riceve _IP datagramma_
    -   con IP mittente e IP destinatario
    -   con numero di porta mittente e destinatario


##### TCP {#tcp}

-   4-tupla
    -   source IP
    -   source port number
    -   dest IP
    -   dest port number


###### Caratteristiche {#caratteristiche}

-   _point-to-point_
-   _reliable_, in-order byte stream
-   _full duplex data_
-   _pipelined_
    -   congestion e flow control impostati a window size
    -   `ACK` cumulativi
        -   del pacchetto che si aspetta di ricevere
-   _connection-oriented_
    -   handshaking
-   _flow controlled_


###### Segmento {#segmento}

-   campi da 32 bit
    -   source port # | dest port #
    -   sequence #
    -   `ACK` #
    -   head len | not used | U | A | P | R | S | F | receive window
    -   checksum | urg data pointer
-   campi a lunghezza variabile
    -   options
    -   application


###### Timeout {#timeout}

-   piú lungo del `RTT` - _Round Trip Time_
    -   ma puó variare
-   corto
    -   trasmissioni non necessarie
-   lungo
    -   trasmissione <span class="underline">poco reattiva</span> a packet-loss
-   Si stima `RTT`
    -   tempo dalla trasmissione alla ricezione `ACK`
    -   si fa una media dei `Sample`
        -   \\(RTT\_{\text{est}} = (1-\alpha)\cdot RTT\_{\text{est}}+\alpha\cdot \text{Sample}\\)
            -   dove solitamente \\(\alpha = 0.125\\)
        -   \\(\textsc{Dev}\_{\textsc{rtt}} = (1-\beta) \cdot \textsc{Dev}\_{\textsc{rtt}} + \beta \cdot |\text{Sample}-RTT\_{\text{est}}|\\)
            -   dove solitamente \\(\beta = 0.25\\)
            -   <span class="underline">margine di sicurezza</span>
    -   \\(\text{TimeoutInterval} = RTT\_{\text{est}} + 4\cdot \textsc{Dev}\_{\textsc{rtt}}\\)
-   timer impostato sul pacchetto piú vecchio di cui non si é ricevuto `ACK`


###### ACK {#ack}

-   vari scenari per ridurre il numero di `ACK`


###### Fast Retransmit {#fast-retransmit}

-   3 `ACK` duplicati indicano che probabilmente un segmento é andato  perso
-   non aspettare il timer ma ritrasmetti immediatamente il segmento _unacked_


###### Connection Management {#connection-management}

-   handshake
    -   si decide di stabilere la connessione
    -   si decidono i parametri di comunicazione
-   socket buffer, variabile
    -   comunicato dal ricevente

Listen &rarr; SYN sent &rarr; Established
Listen &rarr; SYN received &rarr; Established

<!--list-separator-->

-  Congestion Control

    `TCP` é un protocollo _fair_ rispetto alle connessioni e le loro capacitá trasmissive
    Troppe sorgenti che inviano dati ad una velocitá superiore a quella gestibile dalla rete

    -   pacchetti perse per buffer overflow ai router
    -   lunghi ritardi in coda ai buffer dei router

    Con conoscenza perfetta il mittente invierebbe solo quando il router ha spazio libero in buffer, questo ovviamente non puó avvenire.
    Anche se si sapesse prima che il pacchetto é perso per buffer pieno il mittente reinvia
    Le <span class="underline">ritrasmissioni</span> sono il prezzo da pagare per avere un buon throughput

    Due approcci:

    -   _end-end_
        -   congestione inferita dalla perdita e ritardo osservati dai terminali
            -   cambiando la finestra di trasmissione `cwnd`
        -   usato da `TPC`
            -   _additive increase multiplicative decrease_
                -   cresce linearmente, limitata dividendo per 2
            -   mittente incrementa `cwnd` fino a quando rileva perdita
            -   _slow start_
                -   fino alla prima perdita aumenta `cwnd` esponenzialmente
            -   reazione alla perdita
                -   timeout
                    -   finestra di trasmissione torna a 1
                    -   _slow start_ fino a threshold
                -   3 ACK duplicati (uguale al timeout in `TCP` Tahoe)
                    -   finestra di trasmissione dimezzata (`TCP` RENO)
    -   _network-assisted_
        -   router danno feedback ai terminali
        -   bit che indica congestione
        -   esplicita una frequenza di trasmissione per il mittente
        -   `ATM ABR`
            -   servizio elastico
                -   se il cammino é congestionato il mittente viene limitato
                -   se il cammino é libero il mittente viene avvantaggiato
            -   celle Resource Manager
                -   mandate assieme alle celle dei dati
                -   contengono informazioni sulla congestione
                -   restituiti al mittente dal ricevente con i bit intatti

    Le app di multimedia non usano `TCP` per evitare il throttling dovuto al congestion control, tollerano il packet loss.


##### UDP {#udp}

`User Datagram Protocol`

-   bare bones
-   best effort
    -   i segmenti possono essere persi
    -   consegna disordinata
-   **connectionless**
    -   niente handshaking
    -   ogni segmento é gestito indipendentemente
-   usi
    -   streaming
    -   DNS
    -   SNMP

Non avendo connessione iniziale é piú veloce, non ha limiti di congestion control, header piccoli.

-   gestione errori
    -   UDP checksum
        -   mittende e destinatario calcolano la checksum e la confrontano


##### RDT {#rdt}

`Reliable Data Transfer`

-   1.0
    -   channel sottostante perfettamente affidabile
    -   `FSM` separate per sender / receiver
-   2.0 - _errors_
    -   channel sottostante puo' invertire bit
        -   checksum
    -   `ACK`
        -   receiver comunica al sender OK
    -   `NAK`
        -   receiver comunica al sender che si hanno errori
        -   sender ritrasmette
-   2.1
    -   se `ACK` o `NAK` corrotti
        -   ritrasmesso il pacchetto
    -   per gestire i duplicati sender aggiunge numero di sequenza
        -   0 o 1
-   2.2
    -   stessa funzionalitá ma senza `NAK`
    -   `ACK` dell'ultimo pacchetto ricevuto OK invece di `NAK`
-   3.0 - _errors_ and _loss_
    -   il canale sottostante puó anche perdere pacchetti
    -   implementiamo un'attesa ragionevole
        -   dopo di che il mittente se non ha ancora ricevuto `ACK` ritrasmette
        -   i ritardi inducono del lavoro in piú con delle sovrapposizioni di invio e risposta


###### Performance {#performance}

3.0 é corretto, le performance sono problematiche

-   il protocollo limita l'uso delle risorse fisiche disponibili

Il protocollo é molto limitato dal \\(\textsc{rtt}\\) in quanto si deve stare in attesa del `ACK` di risposta per poter procedere


##### Pipelining {#pipelining}

Per risolvere il problema di performance del `RDT` si continuano a trasmettere pacchetti anche durante l'attesa dell'`ACK`
Ci sono due <span class="underline">forme generiche di pipelined protocols</span>:

-   `Go-Back-N`
    -   sender invia fino a `N` pacchetti <span class="underline">unacked</span>
        -   c'é una finestra di grandezza `N` tra tutti i pacchetti comprendente:
            1.  pacchetti inviati, senza `ACK`
            2.  pacchetti disponibili ad essere inviati
    -   receiver invia solo `ACK` cumulativo
        -   non lo invia se c'é un gap
        -   non necessita buffering a questo lato
            -   si riceve solo nell'ordine corretto, altrimenti si scarta
    -   sender ha un timer per il piú vecchio pacchetto unacked
        -   quando scade reinvia tutti i pacchetti unacked
-   `Selective Repeat`
    -   sender invia fino a `N` pacchetti unacked
    -   receiver invia `ACK` singoli
    -   sender ha un timer per ciascun pacchetto unacked
        -   reinvia solo quello relativo allo scadere


#### Livello di Rete {#livello-di-rete}

_Comunicazione logica tra hosts_


##### Datagram {#datagram}

_Internet_
Non c'é setup di chiamata al livello di rete, i router non mantengono stati sulle connessioni.

-   non esiste il concetto di connessione a livello di rete
-   pacchetti inviati usando l'indirizzo di destinazione

Caratteristiche:

-   scambio di dati tra computer
    -   servizio elastico, timing variabile
-   connessioni diverse tra terminali
    -   servizio poco uniforme
-   terminali intelligenti
    -   semplice nella rete, complesso ai terminali


##### Virtual Circuit {#virtual-circuit}

_ATM_
Consiste in:

-   path
-   `VC` number
    -   pacchetti appartenenti a `VC` portano il suo numero invece che l'indirizzo destinazione
-   voci delle _forwarding tables_

-   signalling protocols
    -   setup, mantenimento e teardown `VC`
    -   in `ATM`, frame-delay, X.25
    -   non usato nell'internet odierno

I router `VC` mantengono informazioni sullo stato della connessione.

Tecnologia evoluta dalla telefonia

-   terminali semplici
    -   complessitá all'interno della rete


##### Architettura Router {#architettura-router}

Funzioni principali:

-   routing algorithms / protocol
    -   _routing processor_
-   forwarding datagrams da incoming a outgoing
    -   _high-seed switching fabric_
        -   switching-rate
            -   \\(N\\) multipli del rapporto input/output
        -   tipologie
            -   memory
                -   prima generazione
                -   1 pacchetto alla volta
                -   computer classico, switching sotto diretto controllo della `CPU`
            -   bus
                -   1 pacchetto alla volta
            -   crossbar
                -   piú pacchetti per volta
-   input
    -   line termination
        -   _physical layer_
    -   link layer protocol
        -   _data link layer_
    -   lookup, forwarding, queueing
        -   datagram dest &rarr; lookup con forwarding table
        -   _queuing_ per sovrapposizione di output, per Head-of-the-Line blocking
-   output
    -   datagram buffer, queueing
        -   _scheduling discipline_ sceglie datagrammi in coda
        -   _buffering_ avviene anche con uno switching veloce per via dei pacchetti che vanno allo stesso output
    -   link layer protocol
    -   line termination
-   buffer
    -   dimensione approssimata a \\(\frac{RTT \cdot C}{\sqrt{N}}\\)
        -   \\(C\\) link capacity
        -   \\(N\\) numero di flussi


##### Internet Protocol {#internet-protocol}

`IP`
Protocolli:

-   routing
-   `IP`
    -   altri 20B di intestazioni
    -   complessivamente 40B di overhead (`TCP` + `IP`) per ogni pacchetto
-   `ICMP`


###### IP Fragmentation {#ip-fragmentation}

Diversi collegamenti all'interno della rete hanno `MTU` diversi

-   Max. transfer size

Datagrammi di grandi dimensione frammentati all'interno della rete

-   riasseblati alla destinazione
-   utilizzati i campi dell'intestazione `IP` per riassemblare i ordine corretto
    -   _fragflag_
    -   _offset_
        -   su 13 bit
            -   offset di 8B sul file (moltiplicare per 8 per posizione esatta)


###### Addressing {#addressing}

identificatore a 32-bit per host, interfaccia del router

-   un `IP` per interfaccia
    -   gestiti dall'`ICANN`
        -   Internet Corporation for Assigned Names and Numbers
    -   `IP` assegnati dinamicamente nella sottorete con `DHCP`
        -   client-server
        -   il protocollo permette di utilizzare stessi indirizzi in tempi diversi a host diversi
        -   `DHCP` discover broadcast a tutti
            -   offer
            -   request
            -   `ACK`
-   Classless InterDomain Routing
    -   `CIDR`
    -   porzione di sottorete dell'indirizzo
    -   formato:
        -   `a.b.c.d/x`
            -   x # bit nella porzione di sottorete dell'indirizzo
-   gli ISP prendono carico degli indirizzi di loro dominio e di tutti i pacchetti a loro indirizzati


###### Network Address Translation {#network-address-translation}

`NAT`
Gli indirizzi, anche se di numero molto grande, non soddisfano la domanda

-   in quanto sono assegnati in blocco

Le reti locali utilizzano <span class="underline">un solo IP</span> per tutti i dispositivi

-   i singoli terminali non sono direttamente raggiungibili
    -   livello di sicurezza in piú
-   si puó cambiare `ISP` senza cambiare `IP` a tutti i dispositivi in rete locale

Implementazione:

-   datagrammi in uscita
    -   `IP` sostituito con `NAT`
    -   porta originale sostituita con una porta assegnata a quel pacchetto in particolare
    -   altri pacchetti della stessa connessione riutilizzano sempre la stessa porta assegnata fino a che necessario
-   datagrammi in entrata
    -   tradotto attraverso la `NAT` <span class="underline">translation table</span>

Controverso:

-   i router non dovrebbero modificare le intestazione di livelli superiori, livello di rete e di trasporto
    -   il `NAT` modifica il livello di trasporto
-   viola la comunicazione punto-punto tra host
    -   questo crea problemi nel `P2P` ad esempio
        -   risolvibile attraverso _relay_

Per rendere raggiungibile direttamente dall'esterno un dispositivo posto dietro `NAT` é possibile:

-   associare un indirizzo pubblico ad un indirizzo interno direttamento all'interno del Router
-   utilizzare il protocollo `UPnP`
    -   Universal Plug and Play
    -   automatizza la soluzione statica precedente
-   _relay_


###### ICMP {#icmp}

Protocollo di messaggistica

-   utilizzato da host e router per comunicare informazioni a livello di rete
-   ping

Messaggi `ICMP` costituiti da

-   tipo
-   codice

Utilizzato da `traceroute`


###### IPv6 {#ipv6}

128 bit - 16 Byte
Motivazioni principale

-   estendere lo spazio degli indirizzi
-   migliorare la velocitá di eleborazione dell'intestazione
-   non piú _best-effort_ ed _elastica_ ma per facilitare il Quality of Service

Formato:

-   lunghezza 40B fissa
-   frammentazione non permessa
    -   aggiunge messaggi "Packet Too Big"
        -   sará il mittente ad adeguarsi alla capacitá trasmissiva del collegamento
-   _flow_ label identifica pacchetti della stesso flusso di dati
-   non c'é piú il _checksum_
-   non ci sono piú le _options_
    -   possono essere inserite al di fuori dell'intestazioni

Per la transizioni viene utilzzato il _tunnelling_

-   `IPv6` pacchetti trasportati come _payload_ all'interno di pacchetti `IPv4` attraverso router `IPv4`


##### Routing Algorithms {#routing-algorithms}

vedi: [Cammini Minimi]({{< relref "20210414192432-data_structures.md#cammini-minimi" >}})

Astrazione in forma di grafo
\\(G = (N,E)\\)

-   \\(N\\) insieme di _router_
-   \\(E\\) insieme di _link_

Costi:
\\(c(x,x')\\) - costo link \\((x,x')\\)

Specifiche:

-   global | decentralized
    1.  tutti i router hanno topologia completa
        -   `link state` algorithms
    2.  i router conoscono solamente i vicini direttamente connessi
        -   `distance vector` algorithms
-   static | dynamic
    1.  i cammini cambiano lentamente
    2.  i cammini cambiano velocemente, l'algoritmo puó reagire ai cambiamenti


###### Link-State Routing {#link-state-routing}

[Algoritmo di Dijkstra]({{< relref "20210414192432-data_structures.md#algoritmo-di-dijkstra" >}})

-   \\(O(n^{2})\\)
    -   esiste anche un costo in quanto i router si devono scambiare necessariamente dei messaggi per avere tutte le informazioni sulla topografia
-   esistono implementazioni piú efficienti in \\(O(n\log{n})\\)

I costi dei link sono conosciuti da tutti i router, tutti possono eseguire l'algoritmo di Dijkstra

-   producendo la _forwarding table_ per quel particolare nodo

Sono possibili **oscillazioni**

-   scegliendo un particolare cammino piú efficiente fa si di cambiare il costo stesso del cammino
-   aumentando il traffico per quel collegamento


###### Distance Vector Routing {#distance-vector-routing}

vedi: [Programmazione Dinamica]({{< relref "20210414192358-problems_algorithms.md#programmazione-dinamica" >}})
**Bellman-Ford Equation**

\\(d\_{x}(y) = \text{min}\_{v}\\{c(x,v) + d\_{v}(y)\\}\\)

dove:
\\(\text{min}\_{v}\\) é il minimo calcolato su tutti i vicini \\(v\\) di \\(x\\)

ogni nodo mantiene

-   una stima \\(D\_x(y)\\) per ogni nodo nella rete
-   una stima \\(D\_v(y)\\) dei vicini

quando la propria \\(D\_{x}(y)\\) cambia lo si scambia tra vicini

-   si ricalcolano le stime
-   questo procedimento porta \\(D\_{x}(y)\\) a tendere a \\(d\_{x}(y)\\)

L'algoritmo é

-   _iterativo_
-   _asincrono_
-   _distribuito_

L'algoritmo permette:

-   una veloce propagazione di cambiamenti positivi della rete
-   una lenta propagazione di cambiamenti negativi della rete
    -   _count to infinity problem_
    -   risolvibile attraverso la _poisoned reverse_

In caso di errori questi si propagano nella rete in quanto i router utilizzano i risultati gli uni degli altri


##### Routing {#routing}

Nella realtá:

-   i router non sono tutti identici
-   la struttura reale della rete non é piatta

Principali problemi:

-   scala
-   amministrazione autonoma
    -   ogni admin potrebbe voler controllare il proprio routing

Quindi si utilizza un `Hierarchical Routing`

-   collezioni di router


###### Autonomous Systems {#autonomous-systems}

`AS`

-   Un `ISP` puó consistere di piú `AS`
-   Router nello stesso `AS` utilizzano lo stesso protocollo di routing
    -   Intra-AS routing algorithm
-   Router in `AS` diversi
    -   Inter-AS routing algorithm

Un _gateway router_

-   terminale rispetto al suo `AS`
-   connette a router di altri `AS`


###### RIP {#rip}

-   advertisement a timer
-   se la table cambia si invia advertisement
-   utilizza _poison reverse_ per evitare ping-pong loops
    -   distanza infinita = 16 salti

`RIP` implementata su livello applicativo (daemon), advertisement attraverso pacchetti `UDP`


###### OSPF {#ospf}

`Open Shortest Path First`

-   algoritmo a stato del collegamento
-   calcolo dell'instradamento utilizzando Djikstra
-   advertisement direttamente ai vicini
    -   _advertisement flooding_
    -   propagati per tutto l'`AS`
-   direttamente in datagramma `IP`
    -   non ha bisogno del livello di trasporto
-   i messaggi `ASPF` sono cifrati
-   permette piú cammini a costo minimo
-   ogni link sono possibili metriche diverse per i costi
-   supporto integrato a multicast
-   é possibile strutturare grandi domini in livelli gerarchici ulteriori
    -   area locale - local
    -   area dorsale - backbone


###### BGP {#bgp}

`Border Gateway Protocol`

-   protocollo tra domini
-   `eBGP` info di raggiungibilitá
-   `iBGP` propaga le info di raggiungibilitá ai router interni alla sottorete
-   permette alle sottoreti di informare il resto di Internet della propria esistenza

Si basa sul concetto di _sessione_ di messaggi `BGP`

-   _prefix advertisement_ tra peers
-   si scambiano pacchetti _path vector_
    -   si informano le altre `AS` che cosa é raggiungibile passando dalla propria `AS`
    -   attributi
        -   `AS-PATH`
        -   `NEXT-HOP`
-   connessioni semi-permanenti `TCP`
-   _sessioni_
    -   `eBGP`
    -   `iBGP`
-   _import politics_
    -   i router di frontiera possono avere politiche differenti per selezionare un _advertisement_ piuttosto che un altro per uno stesso prefisso
        -   lunghezza del collegamento
            -   `AS-PATH`
        -


##### Broadcast {#broadcast}

un singolo nodo trasmette a molti

-   duplicazione alla sorgente i pacchetti che invia
    -   inefficente
    -   non é detto che la sorgente conosca tutti gli indirizzi destinatari
-   duplicazione all'interno della rete
    -   _flooding_
        -   un nodo che riceve un pacchetto in broadcast lo duplica e invia a tutti i vicini
        -   puó creare cicli e _broadcast storm_
    -   _controlled flooding_
        -   invia solamente se non giá inviato in precedenza
            -   fatto con i numeri di sequenza (id)
        -   o con `RPF` (Reverse Path Forwanding)
            -   invio del pacchetto solo se é giunto dal cammino piú breve possibile tra nodo e sorgente
    -   _spanning tree_
        -   nessun pacchetto ridondante ricevuto da alcun nodo
        -   un albero non ha cicli
        -   va costruito
            1.  selezione di un nodo centrale
                -   si inviano dei messaggi di `join` dagli altri nodi
                -   questi messaggi sono reinviati fino a che non si raggiunge un nodo giá inserito nell'albero di distribuzione


##### Multicast {#multicast}

sistemi mittenti e sistemi riceventi

-   alcuni fanno parte del gruppo multicast altri no
-   anche router che non hanno membri multicast possono fare parte della rete multicast se essenziali al collegamento

Approcci alla costruzione dell'albero di distribuzione

-   _source-based tree_
    -   shortest path trees
        -   [Algoritmo di Dijkstra]({{< relref "20210414192432-data_structures.md#algoritmo-di-dijkstra" >}})
    -   `RPF`
        -   permette il _pruning_ su sottoalberi che non contengono membri del multicast
-   _group-share tree_
    -   minimal spanning (_Steiner_)
        -   albero a costo minimo che connetta tutti i router con membri
        -   problema NP-completo
        -   l'algoritmo é monolitico
            -   va rieseguito ogni volta che la rete varia
        -   esistono buone euristiche ma rimane poco usato
    -   center-base trees


###### DVMRP {#dvmrp}

`Distance Vector Multicast Routing Protocol`

-   _flood and prune_
    -   `RPF` tree basato sulle routing tables costruite comunicando tra i router `DVMRP`
    -   non assume nulla sull'unicast sottostante
    -   i router non nel gruppo possono mandare messaggi di pruning upstream
-   _soft state_
    -   resetta lo stato a intervalli di tempo
-   _tunnelling_
    -   utilizzato per collegare <span class="underline">fisicamente</span> router multicast che sono connessi logicamente
    -   collegamenti virtuali
        -   datagrammi multicast inseriti in datagrammi non multicast


###### PIM {#pim}

`Protocol Independent Multicast`

-   non dipende dall'algoritmo di routing utilizzato al livello di unicast
-   due scenari di distribuzione
    1.  _dense_
        -   membri posizionati densamente
        -   ampiezza di banda piú importante
        -   i router fanno implicitamente parte della distribuzione
            -   devono chiedere il pruning loro stessi
        -   _data-driven_ mcast tree (`RPF`)
            -   _flood and prune_
            -   meccanismo di protocollo per informare i nodi se sono foglie
    2.  _sparse_
        -   membri largamente sparsi
            -   in reti diverse
        -   ampiezza di banda non altrettanto importante
        -   l'appartenenza al gruppo va richiesta esplicitamente
        -   _receiver-driven_ mcast tree (center-based)
            -   i router inoltrano messaggi di _join_ verso il _rendezvous point_
            -   i messaggi sono inviati tramite `unicast` al centro che poi distribuisce


#### Livello di Collegamento {#livello-di-collegamento}

I protocolli di questo livello lavorano su _frame_, che incapsulano i datagrammi
Il livello tratta di _link_ tra _nodi_

-   wired
-   wireless
-   `LANs`

I protocolli di questo livello si trovano su tutti i nodi della rete

-   _netword interface card_ - `NIC`
    -   scheda di rete

Implementati in parte in <span class="underline">hardware</span>, in parte in <span class="underline">firmware</span> (controller della scheda), in parte in <span class="underline">software</span>


##### Servizi {#servizi}

-   _framing_
    -   incapsulamento di un datatramma
    -   aggiunge header, trailer
    -   accesso condiviso se il medium é condiviso
    -   `MAC` address che identificano sorgente e destinazione del _frame_
-   _trasferimento dati affidabile_
    -   in particolare per i collegamenti con alto tasso di errori
        -   wireless
-   _flow control_
-   _error detection_
-   _error correction_
-   _half-duplex_ - _full-duplex_


##### Errori {#errori}


###### Detection &amp; Correction {#detection-and-correction}

Bit aggiunti al datagramma:

-   `EDC` - Error Detection and Correction bits

I bit sono controllati da ricevente

-   possono esserci errori non rilevati anche se raramente

-   _Parity checking_
    -   paritá singola
        -   permette di individuare errori di singoli bit
        -   non molto sicuro ma semplice e veloce
    -   paritá bidimensionale
        -   permette di individuare e correggere errori di singoli bit
-   **Cyclic Redundancy Check**
    -   \\(R\\) bit tali che
        -   \\(\langle D,R \rangle\\) divisibile per \\(G\\)
    -   permette di individuare fino a \\(r\\) errori di bit consecutivi
        -   questo perché solitamente gli errori si presentano in _burst_
    -   \\(D \cdot 2^{r}\\: \textsc{xor}\\: R = nG\\)


##### Protocolli ad Accesso Multiplo {#protocolli-ad-accesso-multiplo}

Esistono mezzi _broadcast_ condivisi oltre a quelli _point-to-point_

-   si verificano interferenze/collisioni se due o piú nodi trasmettono allo stesso momento

I protocolli di questo tipo:

-   algoritmi distribuiti che determinano quando i nodi possono trasmettere
-   le comunicazioni riguardanti la condivisione del canale possono necessitare il canale stesso
    -   _in-band channel coordination_


###### MAC {#mac}

`Medium Access Control Protocols`

-   _channel partitioning_
    -   suddivisione del canale in parti piú piccole
-   _random access_
    -   il canale non viene suddiviso
    -   permette le collisioni
    -   quando un nodo ha bisogno del mezzo lo utilizza
        -   vengono individuate le collisioni
        -   si specifica come risolvere la collisione
            -   tipicamente con la ritrasmissione ritardata
-   _turns_
    -   i nodi vanno a turni

<!--list-separator-->

-  Channel Partitioning

    <!--list-separator-->

    -  TDMA - channel part

        `Time Division Multiple Access`

        -   accesso diviso su turni
        -   ad ogni nodo é assegnato uno slot temporale
            -   slot non utilizzati vanno sprecati

    <!--list-separator-->

    -  FDMA

        `Frequency Division Multiple Access`

        -   banda divisa in bande piú piccole
            -   su frequenze diverse
        -   ogni nodo é assegnato ad una sotto-banda

<!--list-separator-->

-  Random Access

    <!--list-separator-->

    -  ALOHA

        -   frame di grandezza uguale
        -   tempo diviso in slot uguali
        -   i nodi sono sincronizzati
        -   se 2 piú nodi trasmettono nello stesso slot
            -   tutti i nodi registrano la collisione
        -   quando un nodo riceve un frame, trasmette nello slot successivo
            -   se si verifica una collisione si tenta di ritrasmettere nello slot successivo con una certa probabilitá \\(p\\), altrimenti ritenterá allo slot successivo ancora con la stessa probabilitá

        Quindi:

        -   prob che un nodo abbia successo in un dato slot, \\(p(1-p)^{N-1}\\)
        -   prob che un qualsiasi nodo abbia successo, \\(N\cdot p(1-p)^{N-1}\\)
        -   massima efficienza massimizza questo valore, \\(1/e = 0.37\\)
            -   nel caso migliore solo il 37% del tempo uno slot viene sfruttato

        Nella versione pura, _unslotted_, di `ALOHA` non c'é sincronizzazione e qualsiasi nodo puó trasmettere immediatamente quando necessario

        -   le collisioni avvengono nelle sovrapposizioni tra le trasmissioni
        -   le collisioni aumentano

        In questa versione:

        -   prob che un qualsiasi nodo abbia successo, \\(p \cdot (1-p)^{N-1} \cdot (1-p)^{N-1}\\)
            -   \\(p \cdot (1-p)^{2(N-1)}\\)
        -   massima efficienza \\(1/e = 0.18\\)

    <!--list-separator-->

    -  CSMA

        `Carrier Sense Multiple Access`
        Non interrompe la comunicazione altrui

        -   se il canale viene individuato come in _idle_
            -   trasmette l'intero frame
        -   se il canale é _busy_
            -   rimanda la trasmissione

        A causa del _propagation delay_ le collisioni possono ancora accadere

        -   i nodi potrebbero non accorgersi in tempo che il canale é occupato in realtá
        -   in caso di collisione tutto il tempo di trasmissione viene sprecato

        <!--list-separator-->

        -  CSMA/CD

            `CSMA Collision Detection`

            {{< figure src="~/org/media/img/CSMA-CD.jpg" >}}

            In caso di collisioni si individuano velocemente per interrompere la trasmissione

            -   riduce lo spreco del canale
            -   Collision Detection
                -   `LAN`
                    -   si confronta l'intensitá del segnale trasmesso e ricevuto
                    -   le interferenze creano una variazione di potenza del segnale
                    -   protocollo utilizzato attualmente per reti `Ethernet`
                -   `Wireless`
                    -   piú complesso
                    -   il segnale ricevuto solitamente é attenuato mentre la trasmissione é piú potente
            -   efficienza
                -   \\(t\_{\text{prop}}\\) max delay di propagazione tra 2 nodi
                -   \\(t\_{\text{trans}}\\) tempo di trasmissione di un frame di dimensione massima
                -   \\(\text{efficiency} = \frac{1}{1+ 5\frac{t\_{\text{prop}}}{t\_{\text{trans}}}}\\)
                    -   aumenta con l'aumentare di \\(t\_{\text{trans}}\\)
                    -   aumenta con il diminuire di \\(t\_{\text{prop}}\\)

            <!--list-separator-->

            -  Algoritmo Ethernet CSMA/CD

                -   `NIC` riceve datagramma, crea frame
                -   `NIC` controlla il canale
                    -   se occupato aspetta
                    -   se libero trasmette
                        -   se non determina disturbi durante la trasmissione suppone che il frame sia stato inviato correttamente
                        -   se determina disturbi invia un _jam signal_ e interrompe la trasmissione
                            -   reinvia dopo un determinato quantitativo di tempo
                                -   _binary backoff_
                                -   \\(k\\) casuale tra \\(0\\) e \\(2^{m}-1\\) con \\(m\\) collisioni
                                -   `NIC` aspetta \\(k\cdot512\text{bit}\\)

<!--list-separator-->

-  Turns

    <!--list-separator-->

    -  Polling

        -   nodo _master_ invita i nodi _slave_ a trasmettere a turno
        -   solitamente _slave_ "dumb"
        -   downsides
            -   overhead del _polling_
            -   latenza
            -   singolo punto di fallimento - _master_

    <!--list-separator-->

    -  Token

        -   _token_ di controllo passato da un nodo all'altro in sequenza
        -   downsides
            -   _token_ overhead
            -   latenza
            -   singolo punto di fallimento - _token_
                -   puó essere perso


##### LANs {#lans}


###### Addressing {#addressing}

Il nodo destinazione nella rete locale é individuato con gli indirizzi fisici `MAC` o `LAN`

-   48 bit scritto in `ROM` del `NIC`
    -   scheda di rete
    -   6 coppie esadecimali di 4bit ciascuno
    -   indirizzo piatto, non cambia in base alla rete cui é connessa a differenza dell'indirizzo `IP`
-   l'indirizzo é univoco (unico per la singola scheda)
    -   amministrato da `IEEE` che assegna porzioni di indirizzi a produttori diversi
        -   garantisce l'unicitá
-   utilizzato per trasferire da un'interfaccia ad un altro, stesso `IP` per quanto riguardo il livello di rete

<!--list-separator-->

-  ARP

    `Address Resolution Protocol`
    Passaggio da `IP` a `MAC`

    -   nodo contiene una `ARP` table
        -   associa `IP/MAC`
        -   `<IP;MAC;TTL>`
            -   _Time to Leave_ in quanto il collegamento alla sottorete puó cambiare
    -   quando si necessitá di un `MAC` si manda la richiesta nella propria rete
        -   il nodo cui corrisponde l'`IP` della richiesta e se questo é il suo risponde con il proprio `MAC`
        -   cosí viene popolata la `ARP` table


###### Ethernet {#ethernet}

Inizialmente pensato con una gerarchia definita:

1.  transiver
2.  cavo
3.  interfaccia
4.  controller

Permettava una velocitá tra 10Mbps e 10 Gbps
Inizialmente la topologia era di **bus**
La topologia attuale é quella a **stella**

-   ora con una _switch_ al centro
-   collegamenti diretti tra nodi e _switch_
-   non c'é collisione

I _frame_ Ethernet sono gli stessi indipendentemente dalla velocitá trasmissiva

-   preamble
-   destination (`MAC`)
-   source (`MAC`)
-   type
    -   solitamente `IP` ma puó essere un qualunque protocollo
-   data
-   `CRC`

I _frame_ che non sono indirizzati al ricevente sono scartati

-   _connectionless_
-   _unreliable_
    -   non sono inviati `ACK`
-   protocollo `MAC`: `CSMA/CD` w/ binary backoff
    -   _jam_ signal in caso di disturbo
        -   48 bit
        -   questo quantitativo di bit é utilizzato per attendere un tempo dipendente dalla velocitá del collegamento
    -   attesa esponenziale
        -   l'adattatore tenta di stimare quanti sono gli adattatori coinvolti


###### Switches {#switches}

funzione di `store-and-forward` dei _frame_ Ethernet

-   _trasparenti_
    -   gli host non sono a conoscenza degli switch
-   _plug-and-play_
-   _self-learning_

Grazie a questi sono possibili trasmissioni simultanee

-   riceve i _frame_ e li inserisce in buffer
-   sceglie i buffer del collegamento in uscita desiderato per i pacchetti
    -   le interfaccie sono associate ai nodi raggiungibili tramite una _switch table_
        -   `MAC` - interfaccia - timestamp `TTL`
        -   popolata tramite autoapprendimento
        -   ogni volta che un _frame_ viene ricevuto viene memorizzata l'associazione tra interfaccia e `MAC` del mittente
        -   se il destinatario non é all'interno della tabella allora il _frame_ viene inviato su tutte le interfacce
            -   _flood_
-   le collisioni non avvengono in quanto pacchetti non si incontrano perché smistati su code diverse dallo switch

Gli switch possono essere collegati tra di loro per creare sottoreti e strutture complesse


###### VLANS {#vlans}

Permettono di risolvere problemi di privacy e sicurezza delle `LAN`
Porte di uno _switch_ raggruppate in modo che un solo _switch_ fisico operi come piú dispositivi <span class="underline">virtuali</span>

Se switch diversi fanno parte di una stessa `VLAN` questi sono collegati tra loro da porte particolari:

-   _trunk port_
    -   scambia _frame_ aggiungendo degli identificatori
    -   protocollo `802.1Q VLAN`


##### Virtualizzazione {#virtualizzazione}


###### MPLS {#mpls}

`Multiprotocol Label Switching`

-   goal:
    -   velocizzare l'inoltro
    -   la ricerca dell'`IP` di destinazione nella tabella di inoltro puó essere lenta
    -   introdurre delle etichette per velocizzare lo switching all'interno del frame
        -   _header_ `MPLS`
            -   nuova tabella di inoltro piú efficiente
        -   l'inoltro viene fatto in base all'etichetta e non viene ispezionato l'`IP`
        -   capacitá di bilanciare il carico
            -   l'invio ad uno stesso destinatario puó essere diverso in base all'etichetta associata al _frame_

Simile ai `Circuiti Virtuali`


##### Data Center Netwoking {#data-center-netwoking}

Da decine a centinaia di _hosts_ in prossimitá

L'obiettivo é bilanciare il carico ed evitare bottleneck nell'accesso ai dati

1.  Server rack
2.  `TOR` switches
3.  Tier-2 switches
4.  Tier-1 switches
5.  Access Router
    -   Load Balancer
        -   riceve le richieste client esterne
        -   dirige il traffico nel data center
        -   ritorna i risultati ai client esterni
            -   nasconde l'interno del data center dai client
6.  Border Router

Possono essere possibili diversi schemi di connessione tra i livelli di switch per ottimizzare l'accesso


#### Incapsulamento {#incapsulamento}

Ogni livello che si discende si aggiunge una intestazione


### Sicurezza {#sicurezza}

Non é stata pensata inizialmente con la sicurezza in mente

-   facilitare la comunicazione tra ricercatori
    -   con trasparenza

Malware:

-   virus
-   worm
-   spyware
-   botnet

Attacchi DoS

-   Denial of Service
-   attaccanti rendono le risorse sul server non disponibili per il traffico reale con moltissime richieste

Packet Sniffing

-   con l'accesso ai mezzi trasmissivi (spesso condivisi)
-   intercettazione dei pacchetti trasferiti nel percorso compromesso

IP spoofing

-   invio di pacchetti con IP falso, rubato


### Reti Wireless {#reti-wireless}

Oggigiorno le connessioni Wireless sono in numero molto maggiore rispetto a quelle cablate

-   wireless hosts
    -   mobile o meno
-   stazioni base
    -   funzione di relay tra rete cablata e dispositivi host wireless
    -   torri cellulari
    -   access points
-   wireless link
    -   collegamento tra dispositivi e stazioni base
    -   anche tra stazioni base come collegamento di dorsale, _backbone link_

Modalitá:

-   Infrastruttura
    -   stazioni base cui si connettono i dispositivi che permette il collegamento alla rete Internet
-   ad hoc
    -   non c'é una stazione base
    -   i nodi trasmettono agli altri nodi
    -   i nodi devono organizzare loro stessi una rete
        -   funzioni di _routing_ e _forwarding_
-   single hop
-   multiple hop


#### Collegamento Fisico {#collegamento-fisico}

-   il segnale radio viene attenuato maggiormente con l'attraversamento dell'etere
-   interferenza con altre sorgenti
    -   frequenze occupate da altri
    -   motori
-   il segnale radio viene diffuso in tutte le direzioni e puó essere riflesso, producendo cammini differenti, ritardi e sovrapposizioni

`SNR` - Signal-to-Noise Ratio
`BER` - Bit Error Rate

Questi sono inversamente proporzionali (quasi esponenziale)

-   si aumenta la potenza di segnale in funzione del mezza fisico utilizzato per minimizzare il `BER`
-   un piccolo calo `SNR` introduce un `BER` elevato

Se dei terminali sono nascosti questi non possono verificare le trasmessioni l'uno dell'altro

-   trasmettono comunque e interferiscono tra loro
-   _hidden terminal problem_


#### CDMA {#cdma}

`Code Division Multiple Access`

-   gli utenti condividono la stessa frequenza
-   gli utenti hanno una frequenza di _chipping_ per codificare le proprie trasmissioni
-   il ricevente puó estrarre il segnale utilizzando la frequenza di _chipping_
-   segnali <span class="underline">ortagonali</span>  interferiscono tra loro ma é possibile recuperare i dati originali


#### Protocolli {#protocolli}


##### 802.11 {#802-dot-11}

`Wireless LAN`
Copertura abbastanza limitata ma ad alta velocitá

-   esiste una versione a lunga portata: `802.11a,g point-to-point`
-   2.4GHz - 2.485GHz
    -   11 canali
    -   i canali si sovrappongono, possono avvenire delle interferenze
        -   solo 1, 6, 11 non si sovrappongono
    -   per gestire l'aumento di `BER` si cambia tipo di trasmissione, piú lenta ma anche  piú efficace

Le stazioni base in modalitá infrastruttura sono gli `AP`, Access Points

-   trasparente rispetto alla rete

Le _cells_ sono i `BSS`, Basic Service Sets

-   in modalitá ad hoc contengono solo i terminali

Gli host si associano agli `AP`

-   passive scanning
    -   frame beacon trasmessi dall'`AP`
        -   contiene `SSID` e `MAC` dell'access point
-   active scanning
    -   probe request broadcast
    -   probe request frame dall'`AP`


###### Accesso Multiplo {#accesso-multiplo}

Evitare le collisioni
Utilizza `CSMA`

-   se si nota una trasmissione in corso si aspetta

Rimangono problemi

-   decadimento del segnale
-   terminali nascosti

Non é  implementata collision detection

-   Sender
    -   `DIFS`
        -   timer di attesa
    -   se canale _idle_ dopo `DIFS`
        -   trasmetti frame
    -   altrimenti
        1.  aspetta random backoff time
        2.  trasmetti frame
        3.  aspetta `ACK`, se non lo si riceve si riparte da 1.
-   Receiver
    -   frame ricevuta `OK`
    -   trasmetti `ACK` dopo `SIFS`
        -   `ACK` necessario a causa del problema del terminale nascosto


###### Capacitá ulteriori {#capacitá-ulteriori}

-   power management
    -   nodo si spegne attendendo il prossimo _beacon frame_
    -   `AP` non trasmette nodi a questo nodo


##### 802.15 {#802-dot-15}

Infrastruttura _master_ - _slave_

-   10m di diametro
-   rimpiazza i cavi per device
    -   mouse, tastiere, cuffie
-   ad hoc
    -   non c'é infrastruttura
-   evoluzione del `Bluetooth`
-   `2.4 - 2.5 GHz`
-   fino a `721 kbps`


#### Cellulari {#cellulari}

Basate sul concetto di cella

-   _base station_
    -   potenza molto alta ma per il resto equivalente agli `AP`
-   _air interface_
-   `MSC` - Mobile Switching Center
    -   connette le celle
    -   gestisce la mobilitá dei device
        -   hand-over da una stazione base ad un altra

Tecniche di condivisione di banda:

-   `FDMA / TDMA`
    -   divide spettro in canali di frequenze
    -   divide canali in slot temporali
-   `CDMA`
    -   code division multiple access


##### 2G {#2g}

Voice network

1.  `BSS`
    -   stazioni base
2.  `MSC`
3.  Gateway `MSC`
4.  rete telefonica pubblica, cablata


##### 3G {#3g}

Voice + Data network
Divisione tra le due reti per permettere scalabilitá

1.  `BSS`
2.  radio network controller
    1.  `MSC`
        -   gateway
        -   rete telefonica pubblica
    2.  `SGSN`
        -   `GGSN`
        -   Rete Internet


#### Mobilitá {#mobilitá}

Un dispositivo che si sposta, si connette e disconnette attraverso `AP` diversi

-   la mobilitá piú <span class="underline">elevata</span> si ha quando il dispositivo pur spostandosi e cambiando `AP` mantiene una stessa connessione

-   home network
    -   indirizzo `IP` permanente
-   home agent
    -   gestisce le funzioni di mobilitá per conto del dispositivo mobile quando quest'ultimo non si trova all'interno della rete domestica
-   visited network
-   foreign agent

Ci sono diversi approcci possibili

-   si lascia la gestione ai _router_
    -   non scalabile
    -   le tabelle sarebbero ingestibili con milioni di utenti che si spostano
-   si lascia la gestione ai terminali
    -   _indirect routing_
        -   comunicazione passa per _home agent_ poi per _remote_
    -   _direct routing_
        -   il corrispondente ottiene l'indirizzo _foreign_ del mobile

Il mobile si <span class="underline">registra</span> contattando il _foraign agent_

-   questo contatta l'_home agent_
-   entrambi sanno come contattare l'utente mobile


##### Mobile IP {#mobile-ip}

-   indirect routing
-   agent discovery
    -   agent advertisement
        -   foreign/home agents fanno broadcast di messaggi `ICMP`


##### Cellulare {#cellulare}

-   indirect routing
    -   switching center home controlla il proprio registro
    -   contatta lo switching center visitato creando la connessione


##### Handoff {#handoff}

1.  vecchio `BSS` informa `MSC` dell'handoff
    -   lista di piú di uno `BSS`
2.  `MSC` imposta il cammino per il nuovo `BSS`
3.  nuovo `BSS` alloca canale audio per l'uso
4.  nuovo `BSS` signala `MSC` e vecchio `BSS`
    -   pronto
5.  vecchio `BSS` segnala `MSC`
    -   pronto
6.  mobile nuovo segnale `BSS` per attivare il nuovo canale
7.  mobile segnala attraverso nuovo `BSS` a `MSC`
    -   handoff complete
8.  `MSC` rilascia risorse del vecchio `BSS`

In caso di `MSC` diversi l'originale ha funzione di ancora verso un nuovo `MSC`